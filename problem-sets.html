<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <title>Think Lab - ThinkBigPrep</title>
    <link rel="shortcut icon" href="assets/logo/thinkbigprep-icon.svg" type="image/svg+xml" />
    <link rel="stylesheet" href="css/index.css?v=1.1" />
    <link rel="stylesheet" href="css/timetable.css?v=1.0" />
    <link rel="stylesheet" href="css/login.css?v=1.0" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/bootstrap-icons/1.11.3/font/bootstrap-icons.min.css" />
    <script src="https://unpkg.com/@lottiefiles/dotlottie-wc@0.8.1/dist/dotlottie-wc.js" type="module"></script>
    <style>
      .ps-lottie-wrap{ position: fixed; inset: 0; display: flex; align-items: center; justify-content: center; z-index: 2000; pointer-events: none; }
      /* Tools FAB and windows */
      /* Brand-styled Tools button (match site browns) */
      .tools-fab{ position:fixed; right:18px; bottom:18px; z-index:1100; display:inline-flex; align-items:center; gap:8px; padding:12px 16px; border-radius:9999px; background:#8B4513; color:#fff; border:none; box-shadow:0 12px 28px rgba(0,0,0,.25); cursor:pointer; transition:transform .15s ease, box-shadow .2s ease, padding .22s ease, min-width .22s ease, border-radius .22s ease; }
      .tools-fab:hover{ transform:translateY(-1px); box-shadow:0 16px 36px rgba(0,0,0,.28); }
      .tools-fab.fab-open{ transform:translateY(-6px); min-width:160px; padding-right:22px; border-radius:9999px; }
      .tools-fab .bi{ font-size:1.25rem; }
      .tool-menu{ position:fixed; right:18px; bottom:76px; background:#ffffff; border:1px solid #e5e7eb; border-radius:12px; box-shadow:0 14px 34px rgba(0,0,0,.18); z-index:1100; overflow:hidden; opacity:0; transform:translateY(6px) scale(.96); pointer-events:none; transition:opacity .18s ease, transform .18s ease; }
      .tool-menu.menu-open{ opacity:1; transform:translateY(0) scale(1); pointer-events:auto; }
      .tool-title{ font-weight:600; color:#8B4513; padding:10px 12px 6px; transition:transform .18s ease; }
      .tool-menu.menu-open .tool-title{ transform:translateY(-4px); }
      .tool-menu ul{ list-style:none; margin:0; padding:2px 8px 10px; display:flex; flex-direction:column; gap:10px; max-height:0; overflow:hidden; transition:max-height .26s ease; }
      .tool-menu.menu-open ul{ max-height:520px; }
      .tool-menu li{ margin:0; opacity:0; transform:translateY(6px); transition:opacity .18s ease, transform .18s ease; }
      .tool-menu.menu-open li{ opacity:1; transform:translateY(0); }
      .tool-menu.menu-open li:nth-child(1){ transition-delay:.02s }
      .tool-menu.menu-open li:nth-child(2){ transition-delay:.04s }
      .tool-menu.menu-open li:nth-child(3){ transition-delay:.06s }
      .tool-menu.menu-open li:nth-child(4){ transition-delay:.08s }
      .tool-menu.menu-open li:nth-child(5){ transition-delay:.10s }
      .tool-menu.menu-open li:nth-child(6){ transition-delay:.12s }
      .tool-menu button{ width:100%; padding:14px 14px; font-size:1rem; background:#ffffff; color:#1f2937; border:none; text-align:left; border-radius:12px; cursor:pointer; transition:background .12s ease, transform .08s ease; }
      .tool-menu button:hover{ background:#F4E6D8; }
      .tool-window{ position:fixed; right:24px; bottom:110px; width:480px; height:560px; background:#fff; border:1px solid #e5e7eb; border-radius:12px; box-shadow:0 18px 50px rgba(0,0,0,.25); z-index:1200; overflow:hidden; }
      .tool-window .tool-header{ height:44px; display:flex; align-items:center; justify-content:space-between; padding:0 10px; background:#8B4513; color:#fff; cursor:move; }
      .tool-window .tool-body{ width:100%; height:calc(100% - 44px); background:#fff; }
      .tool-close{ background:transparent; border:none; color:#fff; font-size:1.25rem; cursor:pointer; }
      @media (max-width: 640px){ .tool-window{ width:95vw; height:70vh; right:2.5vw; bottom:100px; } }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/underscore.js/1.13.6/underscore-min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.7.1/jquery.min.js"></script>
    <!-- Perseus dependencies (Khan Academy open-source) -->
    <script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css" />
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/react@18/umd/react.production.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/react-dom@18/umd/react-dom.production.min.js"></script>
    <!-- Desmos Graphing Calculator API -->
    <script src="https://www.desmos.com/api/v1.6/calculator.js?apiKey=dcb31709b452b1cf9dc26972add0fda6"></script>
    <!-- Light-weight stand-in: we'll use a simplified renderer approach that emulates Perseus style -->
    <style>
      .ps-container{display:grid;grid-template-columns:420px minmax(0,1fr);gap:32px;width:min(98vw, 1680px);max-width:1680px;margin:60px auto 40px;padding:0 24px}
      .ps-sidebar{position:sticky;top:96px;align-self:start;height:calc(100vh - 140px);overflow:auto;border:1px solid #e5e7eb;border-radius:12px;padding:12px;background:#fff}
      .ps-section-title{font-size:1.1rem;font-weight:800;color:#8B4513;margin:8px 0 6px}
      .ps-lesson{display:flex;align-items:center;justify-content:space-between;border:1px solid #eee;border-radius:10px;padding:8px 10px;margin:6px 0;background:#F5E6D3;color:#6b3410;cursor:pointer}
      .ps-lesson .status{font-size:.75rem;background:#fff;border:1px solid #e5e7eb;border-radius:9999px;padding:2px 8px}
      .ps-lock{color:#6b3410;opacity:.8;margin-right:6px}
      .ps-progress{height:6px;background:#f3f4f6;border-radius:9999px;overflow:hidden;margin:8px 0}
      .ps-progress>div{height:100%;background:#8B4513}
      .ps-content{border:0;border-radius:12px;padding:18px;background:#fff}
      .ps-breadcrumb{color:#6b7280;font-size:.9rem;margin-bottom:6px}
      .ps-title{font-size:1.6rem;font-weight:800;color:#1a1a1a;margin:6px 0 10px}
      .ps-actions{display:flex;gap:8px;margin-bottom:12px}
      .ps-actions .btn{padding:10px 14px;border-radius:10px}
      .ps-body{line-height:1.7;color:#1a1a1a}
      /* Choice layout: left-align text, allow math inline, and keep button full-width */
      .ps-opts{display:flex;flex-direction:column;gap:10px}
      .ps-opt{display:block;text-align:left;justify-content:flex-start;align-items:flex-start;width:100%;padding:12px 14px;border:1px solid #efe7dc;border-radius:10px;background:#fbf5ee;color:#1a1a1a}
      .ps-opt.sel{outline:2px solid #8B4513;background:#fff}
      .ps-opt .katex{font-size:1.05em}
      @media(max-width:1200px){.ps-container{grid-template-columns:360px minmax(0,1fr);gap:28px}}
      @media(max-width:900px){.ps-container{grid-template-columns:1fr;width:100%;padding:0 16px}.ps-sidebar{position:relative;top:auto;height:auto;overflow:visible}.ps-toggle{display:none}}
      /* Ensure hidden state always respected */
      #psApp[hidden]{display:none !important}
    </style>
  </head>
  <body class="problem-sets">
    <header class="header">
      <div class="header-container">
        <a href="index.html#home" class="logo" style="text-decoration:none;color:inherit;"><img src="./assets/logo/thinkbigprep-logo.svg" alt="ThinkBigPrep"/></a>
        <nav class="nav-desktop">
          <a href="index.html#home">Home</a>
          <a href="timetable.html">Timetable</a>
          <a href="index.html#courses">Plans</a>
          <a href="index.html#coaches">Available Tutors</a>
          <a href="about.html">About Us</a>
          <a href="ai-curriculum.html">AI Curriculum</a>
          <a href="problem-sets.html" class="active">Think Lab <span class="new-tag">NEW</span></a>
          <a href="login.html" class="student-login-link">Student Login</a>
        </nav>
        <button class="mobile-menu-btn" onclick="toggleMobileMenu()"><i class="bi bi-list"></i></button>
      </div>
    </header>

    <section class="timetable-hero">
      <div class="container">
        <h1 class="timetable-title">Think Lab</h1>
        <p class="timetable-subtitle">Customized problem sets powered by Perseus Exercise Renderer</p>
      </div>
    </section>

    <!-- Feature A: 3D Rotating Books Carousel (React + Framer Motion UMD) -->
    <div id="psShelf" aria-label="Subjects">
      <div class="ps-books-grid" id="psBooksGrid"></div>
    </div>

    <main class="ps-container" id="psApp" hidden>
      <aside class="ps-sidebar" id="psSidebar"><div id="psOutline"></div></aside>
      <section class="ps-content">
        <div class="ps-breadcrumb" id="psBreadcrumb">Algebra 1 / Lesson 1</div>
        <h2 class="ps-title" id="psTitle">Linear Equations — Basics</h2>
        <div class="ps-actions" style="display:none"></div>
        <div class="ps-body" id="psBody"></div>
      </section>
    </main>

  

    <footer class="footer">
      <div class="container">
        <div class="footer-content">
          <div class="footer-section">
            <div class="footer-logo"><img src="./assets/logo/thinkbigprep-logo.svg" alt="ThinkBigPrep"/><span>ThinkBigPrep</span></div>
          </div>
          <div class="footer-section">
            <h4>SEE ALSO</h4>
            <ul>
              <li><a href="index.html#home">Home</a></li>
              <li><a href="timetable.html">Timetable</a></li>
              <li><a href="ai-curriculum.html">AI Curriculum</a></li>
              <li><a href="problem-sets.html">Think Lab</a></li>
            </ul>
          </div>
          <div class="footer-section"><h4>CONTACT US</h4><p>Phone: 201-665-0123</p><p>Email: info@thinkbigprep.com</p></div>
        </div>
        <div class="footer-bottom"><p>ThinkBigPrep © 2025</p></div>
      </div>
    </footer>

    <!-- Tools FAB and menu -->
    <button id="tools-fab" class="tools-fab btn btn-primary floating-ai-btn" aria-label="Open Tools"><i class="bi bi-list"></i> Tools</button>
    <div id="tool-menu" class="tool-menu" role="menu" aria-label="Tools menu">
      <div class="tool-title">Tools</div>
      <ul>
        <li><button type="button" id="open-desmos"><i class="bi bi-graph-up"></i> Desmos</button></li>
        <li><button type="button" id="open-numworks"><i class="bi bi-calculator"></i> NumWorks</button></li>
        <li><button type="button" id="open-ti84"><i class="bi bi-calculator-fill"></i> TI-84</button></li>
        <li><button type="button" id="open-study-ai"><i class="bi bi-chat-dots"></i> Study AI</button></li>
        <li><button type="button" id="open-formula"><i class="bi bi-journal-text"></i> Formula sheet</button></li>
        <li><button type="button" id="open-notes"><i class="bi bi-sticky"></i> Notes</button></li>
      </ul>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/framer-motion@10.18.0/dist/framer-motion.umd.js"></script>
    <script>
      // Subject → Subtopics → Lessons; each lesson has notes and MC questions
      const COURSES = [
        { id:'algebra-1', title:'Pre-Algebra', subtopics:[
          { id:'numbers-operations', title:'Numbers & Operations', lessons:[
            { slug:'place-value-rounding', title:'Place value; rounding & estimation', locked:false, notes:`Lesson outline.` },
            { slug:'integer-operations', title:'Integers: add/subtract/multiply/divide', locked:false, notes:`Lesson outline.` },
            { slug:'absolute-value-opposites', title:'Absolute value & opposites', locked:false, notes:`Lesson outline.` },
            { slug:'properties', title:'Properties: commutative, associative, distributive', locked:false, notes:`Lesson outline.` }
          ]},
          { id:'factors-multiples', title:'Factors & Multiples', lessons:[
            { slug:'divisibility-prime-composite', title:'Divisibility rules; prime vs composite', locked:false, notes:`Lesson outline.` },
            { slug:'prime-factorization', title:'Prime factorization', locked:false, notes:`Lesson outline.` },
            { slug:'gcf', title:'Greatest common factor (GCF)', locked:false, notes:`Lesson outline.` },
            { slug:'lcm', title:'Least common multiple (LCM)', locked:false, notes:`Lesson outline.` }
          ]},
          { id:'fractions', title:'Fractions', lessons:[
            { slug:'equivalent-simplifying', title:'Equivalent fractions; simplifying', locked:false, notes:`Lesson outline.` },
            { slug:'add-subtract-fractions', title:'Add/subtract fractions & mixed numbers', locked:false, notes:`Lesson outline.` },
            { slug:'multiply-divide-fractions', title:'Multiply/divide fractions & mixed numbers', locked:false, notes:`Lesson outline.` },
            { slug:'fraction-word-problems', title:'Fraction word problems', locked:false, notes:`Lesson outline.` }
          ]},
          { id:'decimals', title:'Decimals', lessons:[
            { slug:'place-value-rounding-decimals', title:'Place value; rounding', locked:false, notes:`Lesson outline.` },
            { slug:'decimal-operations', title:'Operations with decimals', locked:false, notes:`Lesson outline.` },
            { slug:'convert-frac-dec', title:'Convert fractions ↔ decimals', locked:false, notes:`Lesson outline.` }
          ]},
          { id:'percents', title:'Percents', lessons:[
            { slug:'convert-percent', title:'Convert percent ↔ decimal ↔ fraction', locked:false, notes:`Lesson outline.` },
            { slug:'percent-of-number', title:'Percent of a number', locked:false, notes:`Lesson outline.` },
            { slug:'discount-tax-tip-change', title:'Discount, tax, tip; percent change', locked:false, notes:`Lesson outline.` },
            { slug:'simple-interest-intro', title:'Simple interest (intro)', locked:false, notes:`Lesson outline.` }
          ]},
          { id:'ratios-rates-proportions', title:'Ratios, Rates & Proportions', lessons:[
            { slug:'ratios-unit-rate', title:'Ratios & unit rate', locked:false, notes:`Lesson outline.` },
            { slug:'proportional-relationships', title:'Proportional relationships & tables', locked:false, notes:`Lesson outline.` },
            { slug:'scale-drawings', title:'Scale drawings & maps', locked:false, notes:`Lesson outline.` },
            { slug:'constant-of-prop', title:'Constant of proportionality', locked:false, notes:`Lesson outline.` }
          ]},
          { id:'expressions', title:'Expressions & Properties', lessons:[
            { slug:'variables-evaluating', title:'Variables & evaluating expressions', locked:false, notes:`Lesson outline.` },
            { slug:'combining-like-terms', title:'Combining like terms', locked:false, notes:`Lesson outline.` },
            { slug:'distributive-property', title:'Distributive property', locked:false, notes:`Lesson outline.` },
            { slug:'writing-expressions', title:'Writing expressions from word phrases', locked:false, notes:`Lesson outline.` }
          ]},
          { id:'equations-inequalities', title:'Equations & Inequalities', lessons:[
            { slug:'one-step-equations', title:'One-step equations', locked:false, notes:`Lesson outline.` },
            { slug:'two-step-equations', title:'Two-step equations', locked:false, notes:`Lesson outline.` },
            { slug:'one-step-inequalities', title:'One-step inequalities; graph on a number line', locked:false, notes:`Lesson outline.` },
            { slug:'word-problems-to-eq', title:'Word problems → equations/inequalities', locked:false, notes:`Lesson outline.` }
          ]},
          { id:'order-exponents', title:'Order of Operations & Exponents (Intro)', lessons:[
            { slug:'pemdas', title:'PEMDAS with integers/fractions/decimals', locked:false, notes:`Lesson outline.` },
            { slug:'integer-exponents', title:'Integer exponents; squares & cubes', locked:false, notes:`Lesson outline.` },
            { slug:'roots-conceptual', title:'Square/cube roots (conceptual)', locked:false, notes:`Lesson outline.` },
            { slug:'scientific-notation-intro', title:'Scientific notation (intro)', locked:false, notes:`Lesson outline.` }
          ]},
          { id:'geometry-foundations', title:'Geometry Foundations', lessons:[
            { slug:'points-lines-angles', title:'Points, lines, angles; angle pairs (complementary, supplementary, vertical)', locked:false, notes:`Lesson outline.` },
            { slug:'triangles-quadrilaterals', title:'Triangles & quadrilaterals (classification, interior angles)', locked:false, notes:`Lesson outline.` },
            { slug:'perimeter-area', title:'Perimeter & area (rectangles, triangles, parallelograms, circles)', locked:false, notes:`Lesson outline.` },
            { slug:'surface-volume', title:'Surface area & volume (rectangular prisms; intro cylinders)', locked:false, notes:`Lesson outline.` },
            { slug:'pythagorean-intro', title:'Pythagorean Theorem (intro & simple applications)', locked:false, notes:`Lesson outline.` }
          ]},
          { id:'coordinate-plane', title:'Coordinate Plane & Patterns', lessons:[
            { slug:'plotting-points', title:'Plotting points in all quadrants', locked:false, notes:`Lesson outline.` },
            { slug:'tables-graphs', title:'Tables → graphs; pattern rules', locked:false, notes:`Lesson outline.` },
            { slug:'arithmetic-sequences-intro', title:'Arithmetic sequences (intro)', locked:false, notes:`Lesson outline.` }
          ]},
          { id:'statistics-probability', title:'Statistics & Probability', lessons:[
            { slug:'mmm-range', title:'Mean, median, mode, range', locked:false, notes:`Lesson outline.` },
            { slug:'plots-hist-box', title:'Dot plots, histograms, box plots (reading & making)', locked:false, notes:`Lesson outline.` },
            { slug:'theoretical-vs-experimental', title:'Theoretical vs experimental probability (single events)', locked:false, notes:`Lesson outline.` },
            { slug:'compound-probability', title:'Simple compound probability (independent events)', locked:false, notes:`Lesson outline.` }
          ]},
          { id:'measurement-conversions', title:'Measurement & Conversions', lessons:[
            { slug:'customary-metric', title:'Customary & metric units', locked:false, notes:`Lesson outline.` },
            { slug:'unit-conversions', title:'Unit conversions; dimensional analysis (intro)', locked:false, notes:`Lesson outline.` },
            { slug:'rates-per', title:'Rates as "per" (mph, $/lb, etc.)', locked:false, notes:`Lesson outline.` }
          ]},
        ]},
        { id:'geometry', title:'Geometry', subtopics:[
          { id:'triangles', title:'Triangles & Congruence', lessons:[
            { slug:'triangle-sum', title:'Triangle Angle Sum', locked:false,
              notes:`# Triangle Angle Sum\nInterior angles of a triangle sum to 180°.`,
              questions:[
                { id:'q1', stem:'If two angles are $50^\\circ$ and $60^\\circ$, the third is', options:['$70^\\circ$','$60^\\circ$','$90^\\circ$','$120^\\circ$'], correct:0, explanation:'$180^\\circ - (50^\\circ+60^\\circ) = 70^\\circ$.', tags:['triangles'] }
              ]
            }
          ]}
        ]},
        { id:'algebra', title:'Algebra', subtopics:[
          { id:'quadratics', title:'Quadratics & Complex', lessons:[
            { slug:'vertex-form', title:'Vertex Form Intro', locked:false,
              notes:`# Vertex Form\n$y = a(x-h)^2 + k$`,
              questions:[
                { id:'q1', stem:'Vertex of $y = (x-3)^2+2$ is', options:['$(3,2)$','$(-3,2)$','$(2,3)$','$(3,-2)$'], correct:0, explanation:'$h=3,\\ k=2$', tags:['quadratics'] }
              ]
            }
          ]}
        ]},
        { id:'algebra-2', title:'Algebra II', subtopics:[
          /* -------------------- QUADRATIC EQUATIONS -------------------- */
          { id:'quadratics', title:'Quadratic Equations', lessons:[
            { slug:'quadratic-factoring-sqrt', title:'Factoring & Square Root Property', locked:false,
              notes:`# Quadratic Equations — Factoring & Square Root
A quadratic has the form $ax^2+bx+c=0$ ($a\\ne0$). 
- **Factoring:** $(x-r_1)(x-r_2)=0\\Rightarrow x=r_1, r_2$.
- **Square root property:** If $x^2=k$ then $x=\\pm\\sqrt{k}$.
> Mastery tip: Try factoring first if $ac$ is small; else consider completing the square or the formula.`,
              graphs:[
                { type:'function', expr:'y=x^2-5x+6' },
                { type:'function', expr:'y=x^2-9' }
              ],
              questions:[
                { id:'q1', stem:'Solve $x^2-5x+6=0$.', options:['$x=2,3$','$x=6$','$x=5$','$x=-2,-3$'], correct:0, explanation:'Factor: $(x-2)(x-3)=0$.', tags:['quadratics','factoring'] },
                { id:'q2', stem:'Solve $x^2=49$.', options:['$x=7$','$x=-7$','$x=\\pm 7$','$x=0$'], correct:2, explanation:'Square root property gives $x=\\pm7$.', tags:['quadratics','square-root'] }
              ]
            },
            { slug:'completing-square', title:'Completing the Square', locked:false,
              notes:`# Completing the Square
Rewrite $ax^2+bx+c$ (assume $a=1$ here) as $(x+\\tfrac{b}{2})^2-\\big(\\tfrac{b}{2}\\big)^2+c$ to solve or to graph vertex form.`,
              graphs:[ { type:'function', expr:'y=x^2+6x+5' } ],
              questions:[
                { id:'q1', stem:'Complete the square: $x^2+6x+5 = (x+\\square)^2+\\square$.', options:['$3,-4$','$2,-1$','$3,-9$','$-3,14$'], correct:0, explanation:'Add/subtract $9$: $(x+3)^2-4$.', tags:['quadratics','completing-square'] },
                { id:'q2', stem:'Solve $x^2+6x+5=0$ by completing the square.', options:['$x=-1,-5$','$x=1,5$','$x=-3$','$x=3$'], correct:0, explanation:'$(x+3)^2=4\\Rightarrow x=-3\\pm2$.', tags:['quadratics'] }
              ]
            },
            { slug:'quadratic-formula-discriminant', title:'Quadratic Formula & Discriminant', locked:false,
              notes:`# Quadratic Formula
For $ax^2+bx+c=0$, $\\displaystyle x=\\frac{-b\\pm\\sqrt{b^2-4ac}}{2a}$.
- Discriminant $\\Delta=b^2-4ac$: $\\Delta>0$ two real roots, $\\Delta=0$ one real root, $\\Delta<0$ complex pair.`,
              graphs:[ { type:'function', expr:'y=2x^2+3x-2' } ],
              questions:[
                { id:'q1', stem:'Solve $2x^2+3x-2=0$.', options:['$x=-2,\\tfrac{1}{2}$','$x=2,-\\tfrac{1}{2}$','$x=1,-2$','$x=\\pm\\sqrt{2}$'], correct:0, explanation:'$\\Delta=25$, $x=(-3\\pm5)/4$.', tags:['quadratics','formula'] },
                { id:'q2', stem:'If $b^2-4ac<0$, the roots are…', options:['Real & distinct','Real & equal','Complex conjugates','Undefined'], correct:2, explanation:'Negative discriminant → nonreal complex pair.', tags:['discriminant'] }
              ]
            },
            { slug:'quadratic-applications', title:'Applications of Quadratics', locked:false,
              notes:`# Applications
Model height/area/optimization via $f(x)=ax^2+bx+c$. Vertex $(h,k)$ gives max/min if $a<0$/$a>0$.`,
              graphs:[ { type:'function', expr:'y=-16t^2+32t+5' } ],
              questions:[
                { id:'q1', stem:'For $h(t)=-16t^2+32t+5$, find the time of maximum height.', options:['$t=1$','$t=\\tfrac{32}{32}$','$t=\\tfrac{-b}{2a}=1$','$t=2$'], correct:2, explanation:'$t=-b/(2a)= -32/(2\\cdot -16)=1$.', tags:['applications','vertex'] },
                { id:'q2', stem:'State the axis of symmetry of $y=-2x^2+8x-1$.', options:['$x=2$','$y=2$','$x=-2$','$y=-2$'], correct:0, explanation:'Axis $x=-b/(2a)=2$.', tags:['vertex','axis'] }
              ]
            }
          ]},

          /* -------------------- INEQUALITIES & ABSOLUTE VALUE -------------------- */
          { id:'inequalities', title:'Inequalities & Absolute Value', lessons:[
            { slug:'linear-inequalities', title:'Linear Inequalities', locked:false,
              notes:`# Linear Inequalities
Solve like equations; **flip the sign** when multiplying/dividing by a negative. Use interval notation.`,
              graphs:[ { type:'numberline', expr:'x>3' }, { type:'numberline', expr:'-2<x\\le4' } ],
              questions:[
                { id:'q1', stem:'Solve $-3x+6\\le0$.', options:['$x\\ge2$','$x\\le2$','$x<2$','$x>2$'], correct:1, explanation:'Divide by −3 and flip.', tags:['inequalities'] },
                { id:'q2', stem:'Which interval matches $1<2x+3\\le7$?', options:['$(-1,2]$','$(-2,1]$','$(-3,2]$','$[ -1,2)$'], correct:0, explanation:'Subtract 3: $-2<2x\\le4\\Rightarrow -1<x\\le2$.', tags:['compound-inequality'] }
              ]
            },
            { slug:'poly-inequalities', title:'Polynomial & Rational Inequalities', locked:false,
              notes:`# Polynomial/Rational Inequalities
1) Move all to one side. 2) Factor. 3) Critical values (zeros, undefined). 4) Sign chart on intervals.`,
              graphs:[ { type:'function', expr:'y=(x-1)(x+2)' }, { type:'function', expr:'y=(x-3)/(x+1)' } ],
              questions:[
                { id:'q1', stem:'Solve $(x-1)(x+2)\\ge0$.', options:['$(-\\infty,-2]\\cup[1,\\infty)$','$(-2,1)$','$(-\\infty,-2)\\cup(1,\\infty)$','$[-2,1]$'], correct:0, explanation:'Nonnegative outside the roots.', tags:['polynomial-inequality'] },
                { id:'q2', stem:'Solve $\\dfrac{x-3}{x+1}<0$.', options:['$(-\\infty,-1)\\cup(3,\\infty)$','$(-1,3)$','$(-\\infty,-1)\\cup( -\\infty,3)$','$(-\\infty,-1)\\cup(0,3)$'], correct:1, explanation:'Negative between -1 and 3.', tags:['rational-inequality'] }
              ]
            },
            { slug:'abs-equations-inequalities', title:'Absolute Value Equations/Inequalities', locked:false,
              notes:`# Absolute Value
- Equation: $|x-a|=d\\Rightarrow x=a\\pm d$.
- Inequality: $|x-a|<d\\Rightarrow a-d<x<a+d$; $|x-a|>d\\Rightarrow x<a-d\\text{ or }x>a+d$.`,
              graphs:[ { type:'function', expr:'y=|x-2|' } ],
              questions:[
                { id:'q1', stem:'Solve $|2x-6|=10$.', options:['$x=8$','$x=-2$','$x=8,-2$','$x=2,6$'], correct:2, explanation:'$2x-6=\\pm10\\Rightarrow x=8,-2$.', tags:['absolute-value'] },
                { id:'q2', stem:'Solve $|x+1|<3$.', options:['$x<-2$','$-4<x<2$','$-2<x<4$','$x>2$'], correct:1, explanation:'Center -1, radius 3 → $-4<x<2$.', tags:['absolute-inequality'] }
              ]
            }
          ]},

          /* -------------------- FUNCTIONS & GRAPHING -------------------- */
          { id:'functions', title:'Functions & Graphing', lessons:[
            { slug:'function-basics', title:'Definition, Domain & Range', locked:false,
              notes:`# Functions
A function assigns **each** input exactly one output. Use notation $f(x)$; domain/range depend on algebraic restrictions.`,
              graphs:[ { type:'function', expr:'y=(x^2-1)/(x-1)' }, { type:'function', expr:'y=\\sqrt{x-2}' } ],
              questions:[
                { id:'q1', stem:'For $g(x)=\\dfrac{1}{x-3}$, which $x$ is not allowed?', options:['$x=3$','$x=0$','$x=-3$','$x=1$'], correct:0, explanation:'Denominator $\\ne0$.', tags:['domain'] },
                { id:'q2', stem:'Domain of $f(x)=\\sqrt{x-2}$ is …', options:['$x>2$','$x\\ge2$','all real $x$','$x\\ne2$'], correct:1, explanation:'Even root → radicand $\\ge0$.', tags:['domain','radicals'] }
              ]
            },
            { slug:'combining-composing', title:'Combine & Compose Functions', locked:false,
              notes:`# Combine/Compose
$(f\\circ g)(x)=f(g(x))$. Watch domains of $g$ **and** of $f$ at $g(x)$.`,
              graphs:[ { type:'function', expr:'y=(x+1)^2' } ],
              questions:[
                { id:'q1', stem:'If $f(x)=x^2$ and $g(x)=x+1$, then $(f\\circ g)(x)$ is …', options:['$x^2+1$','$(x+1)^2$','$x^2+x+1$','$x+1$'], correct:1, explanation:'Substitute $g$ into $f$.', tags:['composition'] },
                { id:'q2', stem:'If $f(x)=\\sqrt{x}$ and $g(x)=x-2$, domain of $f\\circ g$?', options:['$x\\in\\mathbb{R}$','$x\\ge0$','$x\\ge2$','$x>2$'], correct:2, explanation:'Need $x-2\\ge0$.', tags:['composition','domain'] }
              ]
            },
            { slug:'inverse-functions', title:'Inverse Functions', locked:false,
              notes:`# Inverses & One-to-One
$f^{-1}$ exists when $f$ is one-to-one (passes horizontal line test). Solve $y=f(x)$ for $x$, then swap.`,
              graphs:[ { type:'function', expr:'y=2x+1' }, { type:'function', expr:'y=(x-1)/2' } ],
              questions:[
                { id:'q1', stem:'Inverse of $f(x)=2x+1$ is …', options:['$2x-1$','$\\tfrac{x-1}{2}$','$\\tfrac{x+1}{2}$','$-2x+1$'], correct:1, explanation:'Solve $y=2x+1\\Rightarrow x=\\tfrac{y-1}{2}$.', tags:['inverse'] },
                { id:'q2', stem:'Which function is NOT one-to-one?', options:['$y=x^3$','$y=e^x$','$y=x^2$','$y=\\ln x$'], correct:2, explanation:'$x^2$ fails horizontal line test.', tags:['one-to-one'] }
              ]
            }
          ]},

          /* -------------------- POLYNOMIALS -------------------- */
          { id:'polynomials', title:'Polynomial Functions', lessons:[
            { slug:'division', title:'Polynomial Division (Long & Synthetic)', locked:false,
              notes:`# Dividing Polynomials
Long division always works; synthetic requires linear divisor $x-c$. **Remainder theorem:** $f(c)$ is the remainder dividing by $(x-c)$.`,
              graphs:[ { type:'function', expr:'y=x^3-6x^2+11x-6' } ],
              questions:[
                { id:'q1', stem:'The remainder of $f(x)$ upon division by $(x-2)$ equals …', options:['$f(2)$','$f(-2)$','$2f(1)$','$0$'], correct:0, explanation:'Remainder theorem.', tags:['division','remainder-theorem'] },
                { id:'q2', stem:'Divide $x^3-1$ by $x-1$. The quotient is …', options:['$x^2+x+1$','$x^2-x+1$','$x+1$','$x^2+1$'], correct:0, explanation:'Geometric sum or synthetic division.', tags:['division'] }
              ]
            },
            { slug:'zeros-graphing', title:'Zeros, Multiplicity & Graphing', locked:false,
              notes:`# Zeros & Graph Shape
Multiplicity odd → **cross**; even → **touch/bounce**. Leading coefficient test sets end behavior.`,
              graphs:[ { type:'function', expr:'y=(x-1)^2(x+2)' } ],
              questions:[
                { id:'q1', stem:'For $f(x)=(x-1)^2(x+2)$, behavior at $x=1$ is …', options:['crosses','touches/bounces','asymptote','hole'], correct:1, explanation:'Even multiplicity.', tags:['multiplicity'] },
                { id:'q2', stem:'End behavior of $y=-3x^5+\\cdots$?', options:['$\\nearrow\\nearrow$','$\\searrow\\searrow$','$\\nearrow\\searrow$','$\\searrow\\nearrow$'], correct:3, explanation:'Odd degree, negative leading → left up, right down.', tags:['end-behavior'] }
              ]
            },
            { slug:'rational-root-partial-frac', title:'Rational Root Test & Partial Fractions', locked:false,
              notes:`# Rational Root Theorem
Candidates: $\\pm\\frac{p}{q}$ where $p\\mid a_0$, $q\\mid a_n$. 
# Partial Fractions (proper rational)
Decompose into simpler rational terms (for distinct linear factors, $\\tfrac{A}{x-r}$, etc.).`,
              graphs:[ { type:'function', expr:'y=(2x+3)/(x^2-1)' } ],
              questions:[
                { id:'q1', stem:'Possible rational zeros of $2x^3-5x^2+x-3$ include …', options:['$\\pm1,\\pm3,\\pm\\tfrac{1}{2},\\pm\\tfrac{3}{2}$','$\\pm2,\\pm3$','$\\pm\\tfrac{1}{3}$','only $\\pm1$'], correct:0, explanation:'$p\\in\\{\\pm1,\\pm3\\}$, $q\\in\\{\\pm1,\\pm2\\}$.', tags:['rational-root'] },
                { id:'q2', stem:'Denominator factors to $(x-1)(x+1)$. A valid partial fraction form is …', options:['$\\dfrac{A}{x-1}+\\dfrac{B}{x+1}$','$\\dfrac{A}{x^2+1}$','$A(x-1)+B(x+1)$','$\\dfrac{A}{x-1}+B$'], correct:0, explanation:'Distinct linear factors → two simple terms.', tags:['partial-fractions'] }
              ]
            }
          ]},

          /* -------------------- EXPONENTIALS & LOGS -------------------- */
          { id:'exp-log', title:'Exponential & Logarithmic Functions', lessons:[
            { slug:'exponentials', title:'Exponential Functions', locked:false,
              notes:`# Exponentials
$f(x)=a\\,b^x$ with $b>0,b\\ne1$. Growth if $b>1$, decay if $0<b<1$. Special: $f(x)=e^x$.`,
              graphs:[ { type:'function', expr:'y=2^x' }, { type:'function', expr:'y=(1/2)^x' } ],
              questions:[
                { id:'q1', stem:'Which is exponential decay?', options:['$2^x$','$3^x$','$(1/2)^x$','$x^2$'], correct:2, explanation:'Base between 0 and 1.', tags:['exponential'] },
                { id:'q2', stem:'$e^x$ is the exponential with base …', options:['$2$','$10$','$e$','$\\ln$'], correct:2, explanation:'By definition.', tags:['exponential'] }
              ]
            },
            { slug:'logarithms', title:'Logarithms & Properties', locked:false,
              notes:`# Logarithms
$\\log_b a=x \\iff b^x=a$. Properties: $\\log_b(MN)=\\log_bM+\\log_bN$, $\\log_b(M^k)=k\\log_bM$, change of base: $\\log_b a=\\tfrac{\\log a}{\\log b}$.`,
              graphs:[ { type:'function', expr:'y=\\log_{10}(x)' }, { type:'function', expr:'y=\\ln x' } ],
              questions:[
                { id:'q1', stem:'$\\log_2(32)$ equals …', options:['$4$','$5$','$3$','$2$'], correct:1, explanation:'$2^5=32$.', tags:['log'] },
                { id:'q2', stem:'$\\log_b a=\\dfrac{\\ln a}{\\ln b}$ is called …', options:['product rule','change of base','power rule','quotient rule'], correct:1, explanation:'Standard change of base.', tags:['log'] }
              ]
            },
            { slug:'solve-exp-log', title:'Solving Exponential/Log Equations', locked:false,
              notes:`# Solving
- Exponential: isolate base$^{\\text{(stuff)}}$ and use logs if needed.
- Logarithmic: combine logs, convert to exponential; check **domain**.`,
              graphs:[ { type:'function', expr:'y=3\\cdot 2^x' } ],
              questions:[
                { id:'q1', stem:'Solve $2^x=20$ (exact).', options:['$x=\\log_2 20$','$x=\\ln20$','$x=20\\ln2$','$x=20$'], correct:0, explanation:'Take $\\log_2$ (or ln): $x=\\ln20/\\ln2$.', tags:['solve-exponential'] },
                { id:'q2', stem:'Solve $\\ln(x-1)=3$.', options:['$x=20$','$x=e^3+1$','$x=e^3-1$','$x=3$'], correct:1, explanation:'Exponentiate: $x-1=e^3\\Rightarrow x=e^3+1$.', tags:['solve-log'] }
              ]
            },
            { slug:'applications-exp', title:'Applications: Growth, Decay, Interest', locked:false,
              notes:`# Applications
- Continuous growth/decay: $A(t)=A_0e^{kt}$.
- Compound interest: $A=P\\big(1+\\tfrac{r}{n}\\big)^{nt}$; continuous: $A=Pe^{rt}$.`,
              graphs:[ { type:'function', expr:'y=e^{0.3x}' }, { type:'function', expr:'y=e^{-0.4x}' } ],
              questions:[
                { id:'q1', stem:'$A=Pe^{rt}$ with $P=1000,r=0.06,t=5$. Exact $A$ is …', options:['$1000e^{0.3}$','$1000\\cdot 1.06^5$','$1000e^{0.06/5}$','$1000e^{5/0.06}$'], correct:0, explanation:'Continuous compounding.', tags:['applications','interest'] },
                { id:'q2', stem:'In $A=A_0e^{kt}$, $k<0$ indicates …', options:['growth','decay','periodic','constant'], correct:1, explanation:'Negative rate → decay.', tags:['growth-decay'] }
              ]
            }
          ]},

          /* -------------------- SYSTEMS -------------------- */
          { id:'systems', title:'Systems of Equations', lessons:[
            { slug:'linear-systems-2', title:'Two-Variable Linear Systems', locked:false,
              notes:`# Substitution & Elimination
Solve $\\begin{cases}a_1x+b_1y=c_1\\\\a_2x+b_2y=c_2\\end{cases}$ by substitution or elimination. Check for inconsistent or dependent systems.`,
              graphs:[ { type:'function', expr:'y=2x+1' }, { type:'function', expr:'y=-x+7' } ],
              questions:[
                { id:'q1', stem:'Solve $\\{\\,y=2x+1,\\;x+y=7\\,\\}$.', options:['$(2,5)$','$(3,7)$','$(4,9)$','$(1,6)$'], correct:0, explanation:'Substitute: $x+2x+1=7\\Rightarrow x=2,y=5$.', tags:['systems','substitution'] },
                { id:'q2', stem:'Type of system if lines have equal slopes but different intercepts?', options:['Dependent','Inconsistent','Unique solution','Nonlinear'], correct:1, explanation:'Parallel distinct lines → no solution.', tags:['systems'] }
              ]
            },
            { slug:'matrix-method', title:'Augmented Matrix (Gauss-Jordan)', locked:false,
              notes:`# Matrices
Use row operations to reach RREF and read solutions; detect inconsistent (row $[0\\ 0\\ |\\ k]$) or dependent (free variables).`,
              graphs:[],
              questions:[
                { id:'q1', stem:'Row $[0\\ 0\\ |\\ 5]$ in RREF implies …', options:['unique solution','infinitely many','no solution','need more steps'], correct:2, explanation:'Contradiction → inconsistent.', tags:['matrices'] },
                { id:'q2', stem:'A free variable appears when …', options:['a pivot in every column','no pivot in a variable column','two pivots per row','RREF reached'], correct:1, explanation:'No pivot → parameter, infinite solutions.', tags:['matrices'] }
              ]
            },
            { slug:'nonlinear-systems', title:'Nonlinear Systems', locked:false,
              notes:`# Nonlinear
Solve intersections such as line–circle, parabola–line, by substitution or elimination; check extraneous roots.`,
              graphs:[ { type:'function', expr:'y=x+1' }, { type:'function', expr:'(x-2)^2+(y-3)^2=25' } ],
              questions:[
                { id:'q1', stem:'Line $y=x+1$ with circle $(x-2)^2+(y-3)^2=25$: the system has …', options:['0 pts','1 pt','2 pts','infinitely many'], correct:2, explanation:'A secant typically intersects a circle twice (unless tangent or disjoint).', tags:['nonlinear'] },
                { id:'q2', stem:'Best first step for parabola–line system?', options:['Factor denominators','Use Gauss-Jordan','Substitute the linear into the quadratic','Take logs'], correct:2, explanation:'Substitution reduces to a quadratic.', tags:['strategy'] }
              ]
            }
          ]}
        ]},
        { id:'precalculus', title:'Pre-Calculus', subtopics:[
          { id:'functions', title:'Functions & Graphs', lessons:[
            { slug:'domain-range', title:'Domain & Range Basics', locked:false,
              notes:`# Domain & Range\nConsider restrictions like division by zero, even roots.`,
              questions:[
                { id:'q1', stem:'Domain of $f(x)=\\dfrac{1}{x-2}$', options:['$x\\ne2$','$x\\ge2$','$x\\le2$','all real $x$'], correct:0, explanation:'Denominator cannot be zero.', tags:['functions'] }
              ]
            }
          ]}
        ]},
        { id:'calculus', title:'Calculus', subtopics:[
          { id:'limits', title:'Limits & Continuity', lessons:[
            { slug:'limit-basics', title:'Limit Basics', locked:false,
              notes:`# Limits\n$\\lim_{x\\to a} f(x)$ describes approaching behavior.`,
              questions:[
                { id:'q1', stem:'$\\lim_{x\\to 0} (2x) =\ ?$', options:['$0$','$1$','$2$','DNE'], correct:0, explanation:'$2x \\to 0$ as $x\\to0$.', tags:['limits'] }
              ]
            }
          ]}
        ]}
      ];

      function saveProgress(key, value){ try { localStorage.setItem(key, JSON.stringify(value)); } catch{} }
      function getProgress(key, fallback){ try { const v = localStorage.getItem(key); return v ? JSON.parse(v) : fallback; } catch{ return fallback; } }

      function renderSidebar(){
        const root = document.getElementById('psOutline');
        root.innerHTML = '';
        // Course selector
        const selectWrap = document.createElement('div'); selectWrap.style.margin='4px 0 10px';
        const select = document.createElement('select'); select.style.width='100%'; select.style.padding='8px'; select.style.borderRadius='8px'; select.style.border='1px solid #e5e7eb';
        COURSES.forEach(c=>{ const opt=document.createElement('option'); opt.value=c.id; opt.textContent=c.title; if (c.id===currentCourseId) opt.selected=true; select.appendChild(opt); });
        selectWrap.appendChild(select); root.appendChild(selectWrap);

        const course = COURSES.find(c=>c.id===currentCourseId) || COURSES[0];
        const h = document.createElement('div'); h.className='ps-section-title'; h.textContent = course.title; root.appendChild(h);
        const progKey = `ps-progress-${course.id}`;
        const progVal = getProgress(progKey, 0);
        const bar = document.createElement('div'); bar.className='ps-progress'; bar.innerHTML = `<div style="width:${Math.round(progVal*100)}%"></div>`; root.appendChild(bar);

        (course.subtopics||[]).forEach(st => {
          const stHdr = document.createElement('div');
          stHdr.className = 'ps-lesson';
          stHdr.style.fontWeight='700'; stHdr.style.background='#fff';
          stHdr.innerHTML = `<span>${st.title}</span><i class="bi bi-caret-down-fill"></i>`;
          root.appendChild(stHdr);
          const ul = document.createElement('div'); ul.style.margin='6px 0 10px'; ul.style.paddingLeft='8px'; root.appendChild(ul);
          let expanded = true;
          function toggle(){ expanded = !expanded; ul.style.display = expanded ? '' : 'none'; stHdr.querySelector('i').className = expanded ? 'bi bi-caret-down-fill' : 'bi bi-caret-right-fill'; }
          stHdr.addEventListener('click', toggle);

          (st.lessons||[]).forEach(lesson => {
            const row = document.createElement('div'); row.className='ps-lesson'; row.dataset.slug = `${course.id}/${st.id}/${lesson.slug}`;
            const left = document.createElement('div');
            left.style.display='inline-flex'; left.style.alignItems='center';
            if (lesson.locked) { const i=document.createElement('i'); i.className='bi bi-lock ps-lock'; left.appendChild(i); }
            const t=document.createElement('span'); t.textContent=lesson.title; left.appendChild(t);
            const right = document.createElement('div'); right.className='status';
            const score = getProgress(`ps-best-${course.id}-${st.id}-${lesson.slug}`, 0);
            right.innerHTML = lesson.locked? 'Locked' : (score>0? `<span class="ps-badge"><i class="bi bi-check-circle"></i>${Math.round(score*100)}%</span>`:'Start');
            row.appendChild(left); row.appendChild(right);
            row.addEventListener('click', ()=> loadLesson(course.id, st.id, lesson.slug));
            ul.appendChild(row);
          });
        });

        select.addEventListener('change', ()=>{
          currentCourseId = select.value;
          renderSidebar();
          const c = COURSES.find(x=>x.id===currentCourseId);
          if (c && c.subtopics && c.subtopics[0] && c.subtopics[0].lessons && c.subtopics[0].lessons[0]){
            loadLesson(c.id, c.subtopics[0].id, c.subtopics[0].lessons[0].slug);
          }
        });
      }

      function mdToHtml(md){
        return md
          .replace(/^# (.*)$/gm, '<h3>$1</h3>')
          .replace(/^## (.*)$/gm, '<h4>$1</h4>')
          .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
          .replace(/\n/g, '<br/>');
      }

      function loadLesson(courseId, subtopicId, lessonSlug){
        const course = COURSES.find(c=>c.id===courseId); if (!course) return;
        const subtopic = (course.subtopics||[]).find(s=>s.id===subtopicId) || (course.subtopics||[])[0]; if (!subtopic) return;
        const lesson = (subtopic.lessons||[]).find(l=>l.slug===lessonSlug) || subtopic.lessons[0]; if (!lesson || lesson.locked) return;

        document.getElementById('psBreadcrumb').textContent = `${course.title} / ${subtopic.title} / ${lesson.title}`;
        document.getElementById('psTitle').textContent = lesson.title;
        renderLessonContent(course, subtopic, lesson);

        // compute overall course progress as average of best lesson scores across subtopics
        const allLessons = course.subtopics.flatMap(st=> st.lessons || []);
        const avg = allLessons.length ? allLessons.reduce((s,l)=> s + getProgress(`ps-best-${course.id}-${subtopic.id === (course.subtopics[0]||{}).id ? subtopic.id : (course.subtopics.find(st=> st.lessons.includes(l))||{}).id}-${l.slug}`, 0), 0) / allLessons.length : 0;
        saveProgress(`ps-progress-${courseId}`, avg);
        renderSidebar();
        history.replaceState(null, '', `problem-sets.html#/${courseId}/${subtopic.id}/${lesson.slug}`);
      }

      async function renderLessonContent(course, subtopic, lesson){
        const body = document.getElementById('psBody');
        const lessonKey = `${course.id}-${subtopic.id}-${lesson.slug}`;
        try { window.__PS_ACTIVE_LESSON_KEY = lessonKey; } catch {}
        body.innerHTML = '';
        // Lesson outline removed per request
        try {
          if (window.katex && window.renderMathInElement){
            window.renderMathInElement(notes, { delimiters:[{left:"$$", right:"$$", display:true},{left:"$", right:"$", display:false},{left:"\\(", right:"\\)", display:false}], throwOnError:false });
          }
        } catch{}

        // Wait for Gemini to load questions; no local template prefill
        let problems = [];
        const groups = { easy:[], medium:[], hard:[] };
        let globalId = 0; const used = new Set();
        let orderedProblems = null; let orderedPointer = 0;
        function enforceBanding(list){
          if (!Array.isArray(list)) return [];
          const ten = list.slice(0,10);
          for (let i=0;i<ten.length;i++){
            const stage = (i<3)? 'easy' : (i<6? 'medium' : 'hard');
            ten[i].difficulty = stage;
          }
          return ten;
        }

        // Ensure each stem varies in wording (not only numbers)
        function normalizeStemText(text){
          try {
            return String(text||'')
              .toLowerCase()
              // collapse LaTeX math blocks to a token
              .replace(/\$[^$]*\$/g, '$x$')
              // numbers and simple fractions to #
              .replace(/-?\d+(?:\.\d+)?/g, '#')
              .replace(/\\dfrac\{[^}]*\}\{[^}]*\}/g, '$f$')
              .replace(/[()^*=+\\/]/g, ' ')
              .replace(/\s+/g, ' ')
              .trim();
          } catch { return String(text||''); }
        }
        function mutateStemWording(stem, difficulty, attempt){
          let s = String(stem||'');
          const swaps = [
            [/^Compute\b/i, 'Evaluate'],
            [/^Evaluate\b/i, 'Find the value of'],
            [/^Find\b/i, 'Determine'],
            [/^Which is greater\b/i, 'Select the greater value'],
            [/^Round\b/i, 'Round off'],
            [/^Simplify\b/i, 'Reduce'],
            [/^Solve\b/i, 'Find the solution to']
          ];
          for (const [pat, repl] of swaps){ if (pat.test(s)) { s = s.replace(pat, repl); break; } }
          // add light context based on difficulty/attempt
          if (attempt % 3 === 1){
            s = `Quick check: ${s}`;
          } else if (attempt % 3 === 2){
            s = (difficulty==='hard' ? `Multi-step: ${s}` : `Mental math: ${s}`);
          }
          return s;
        }
        function makeStemsUnique(list){
          const seen = new Set();
          for (let i=0;i<list.length;i++){
            if (!list[i] || !list[i].stem) continue;
            let s = list[i].stem;
            let norm = normalizeStemText(s);
            let attempts = 0;
            while (seen.has(norm) && attempts < 3){
              s = mutateStemWording(s, list[i].difficulty||'medium', attempts+1);
              norm = normalizeStemText(s);
              attempts++;
            }
            list[i].stem = s;
            seen.add(norm);
          }
          return list;
        }
        // Per-lesson cache (localStorage)
        function getLessonCacheKey(course, subtopic, lesson){
          const c = (course&&course.id)||'c';
          const s = (subtopic&&subtopic.id)||'s';
          const l = (lesson&&lesson.slug)||'l';
          return `ps-qa-cache-${c}-${s}-${l}`;
        }
        function getCachedProblems(course, subtopic, lesson, maxAgeMs){
          try {
            const key = getLessonCacheKey(course, subtopic, lesson);
            const raw = localStorage.getItem(key);
            if (!raw) return null;
            const parsed = JSON.parse(raw);
            if (!parsed || !Array.isArray(parsed.items) || typeof parsed.ts !== 'number') return null;
            if (Date.now() - parsed.ts > (maxAgeMs||86400000)) return null; // default 24h
            return parsed.items;
          } catch { return null; }
        }
        function setCachedProblems(course, subtopic, lesson, problems){
          try {
            const key = getLessonCacheKey(course, subtopic, lesson);
            const payload = { ts: Date.now(), items: problems };
            localStorage.setItem(key, JSON.stringify(payload));
          } catch {}
        }
        function isWordProblemStem(text){
          try {
            const s = String(text||'').toLowerCase();
            const wordCues = ['miles','kilometers','feet','inches','pounds','dollars','yen','cost','price','bank','balance','account','interest','tax','tip','store','shop','ticket','temperature','degrees','celsius','fahrenheit','elevation','sea level','above','below','distance','speed','rate','time','minutes','hours','days','deposit','withdraw','spent','bought','paid','owes','loan','recipe','mixture','class','students','apples','books','boxes','travel','trip','bus','train','water','tank','pool','garden','field','work'];
            const hasCue = wordCues.some(k=> s.includes(k));
            const hasSentence = /[a-z]{3,}\s+[a-z]{3,}/.test(s) && /[.?]/.test(s);
            const mathOnly = /^\s*(\$[^$]*\$|[-+*/^()=0-9\\\s])+\s*$/.test(s);
            return (hasCue || hasSentence) && !mathOnly;
          } catch { return false; }
        }
        // Scenario key to avoid repeating the same context (e.g., submarine/sea-level) too often
        function scenarioKey(text){
          try {
            const s = String(text||'').toLowerCase();
            if (/(submarine|underwater|sea level|ocean)/.test(s)) return 'sea';
            if (/(bank|account|balance|deposit|withdraw|debt|credit|loan)/.test(s)) return 'bank';
            if (/(temperature|degrees|celsius|fahrenheit)/.test(s)) return 'temp';
            if (/(elevator|floor|stairs)/.test(s)) return 'elevator';
            if (/(mountain|hike|altitude|elevation)/.test(s)) return 'mountain';
            return 'generic';
          } catch { return 'generic'; }
        }
        function selectDiverseTen(pool){
          const unique = [];
          const seen = new Set();
          for (let i=0;i<pool.length && unique.length<50;i++){
            const p = pool[i]; if (!p || !p.stem) continue;
            // Lighter normalization to allow numeric variants to count as distinct
            const norm = String(p.stem||'').toLowerCase().replace(/\s+/g,' ').trim();
            if (!seen.has(norm)){ unique.push(p); seen.add(norm); }
          }
          // Enforce differentiation by rotating across structural clusters and scenarios
          function structureKey(s){
            const t = String(s||'').toLowerCase();
            if (/(which is greater|compare|always true|must be true)/.test(t)) return 'compare';
            if (/(translate|expression|equation)/.test(t)) return 'translate';
            if (/(graph|coordinate|point|slope)/.test(t)) return 'graph';
            if (/(round|nearest|estimate)/.test(t)) return 'round';
            if (/(percent|%)/.test(t)) return 'percent';
            if (/(ratio|unit rate|proportion)/.test(t)) return 'ratio';
            if (/(gcf|greatest common factor|lcm|least common multiple)/.test(t)) return 'factor';
            if (/(simplify|combine like terms|distributive)/.test(t)) return 'algebra';
            return 'compute';
          }
          const buckets = new Map();
          unique.forEach(p=>{ const k = structureKey(p.stem); if(!buckets.has(k)) buckets.set(k, []); buckets.get(k).push(p); });
          const keys = Array.from(buckets.keys());
          const rotated = [];
          let idx=0; let guard=0;
          while (rotated.length < 12 && keys.length && guard++ < 100){
            const k = keys[idx % keys.length];
            const arr = buckets.get(k) || [];
            if (arr.length){ rotated.push(arr.shift()); }
            if (!arr.length){ buckets.delete(k); keys.splice(idx % keys.length, 1); idx = 0; continue; }
            idx++;
          }
          const pool2 = rotated.length ? rotated : unique;
          const word = [], non = [];
          for (const p of pool2){ (isWordProblemStem(p.stem) ? word : non).push(p); }
          const out = [];
          const scenCount = { sea:0, bank:0, temp:0, elevator:0, mountain:0, generic:0 };
          // First 6: prefer non-word problems (mix in if non is short)
          let iNon = 0, iWord = 0;
          while (out.length < 6 && (iNon < non.length || iWord < word.length)){
            if (iNon < non.length) out.push(non[iNon++]);
            else if (iWord < word.length) out.push(word[iWord++]);
            else break;
          }
          // Last 4: prefer word problems when available
          while (out.length < 10 && iWord < word.length){
            const cand = word[iWord++];
            const sk = scenarioKey(cand.stem);
            // Completely skip sea-level / submarine scenarios
            if (sk === 'sea') continue;
            if ((scenCount[sk]||0) < 2){ out.push(cand); scenCount[sk] = (scenCount[sk]||0)+1; }
          }
          // If still short, fill with remaining items regardless of type
          const rest = non.slice(iNon).concat(word.slice(iWord));
          while (out.length < 10 && rest.length){
            const cand = rest.shift();
            const sk = scenarioKey(cand.stem);
            if (sk === 'sea') continue;
            if ((scenCount[sk]||0) < 2){ out.push(cand); scenCount[sk] = (scenCount[sk]||0)+1; }
          }
          return out.slice(0,10);
        }
        function classify(p, index){
          const d = String((p.difficulty||'').toLowerCase());
          if (d==='easy'||d==='medium'||d==='hard') return d;
          if (typeof index === 'number') return index < 10? 'easy' : (index < 20? 'medium' : 'hard');
          return 'medium';
        }
        function isProbablyLatex(text){
          try {
            const s = String(text||'');
            if (/\$[^$]+\$/.test(s)) return true;          // $...$
            if (/\\\([\s\S]*?\\\)/.test(s)) return true; // \( ... \)
            if (/\\\[[\s\S]*?\\\]/.test(s)) return true; // \[ ... \]
            return false;
          } catch { return false; }
        }
        function latexEscapeText(text){
          let s = String(text||'');
          s = s.replace(/[\\]/g, '\\textbackslash{}')
               .replace(/#/g, '\\#')
               .replace(/\$/g, '\\$')
               .replace(/%/g, '\\%')
               .replace(/&/g, '\\&')
               .replace(/_/g, '\\_')
               .replace(/\^/g, '\\^{}')
               .replace(/\{/g, '\\{')
               .replace(/\}/g, '\\}')
               .replace(/</g, '\\textless{}')
               .replace(/>/g, '\\textgreater{}')
               .replace(/\n+/g, ' ');
          return s;
        }
        function containsLatexCommand(t){
          try { return /\\(frac|dfrac|underline|sqrt|cdot|times|left|right|overline|vec|angle|pi|theta|alpha|beta|sum|int|lim|sin|cos|tan|log|ln|circ|degree|text)\b/.test(String(t||'')); } catch { return false; }
        }
        function wrapLatexFragments(t){
          try {
            let s = String(t||'');
            // Wrap bare LaTeX command blocks with inline math if not already
            s = s.replace(/(\\[a-zA-Z]+(?:\{[^}]*\})+)/g, (m)=> `$${m}$`);
            // Wrap \( ... \) and \[ ... \] with $ $ for uniform renderer
            s = s.replace(/\\\(([\s\S]*?)\\\)/g, (m, inner)=> `$${inner}$`);
            s = s.replace(/\\\[([\s\S]*?)\\\]/g, (m, inner)=> `$$${inner}$$`);
            return s;
          } catch { return String(t||''); }
        }
        function fixCommonLatexTypos(t){
          try {
            let s = String(t||'');
            // Fix $/text{...} -> $\text{...}
            s = s.replace(/\$\s*\/\s*text\s*\{/g, '$\\text{');
            // Fix \{}underline{...} -> \underline{...}
            s = s.replace(/\\\{\}underline/g, '\\underline');
            // Fix $ext{...} -> $\text{...} and bare ext{...} -> \text{...}
            s = s.replace(/\$\s*ext\s*\{/g, '$\\text{');
            s = s.replace(/(^|\s)ext\s*\{/g, '$1\\text{');
            // Unescape escaped braces (common leak)
            s = s.replace(/\\\{/g, '{').replace(/\\\}/g, '}');
            // Strip \text{...} wrapper if it only contains math
            s = s.replace(/\\text\{\s*([^}]*)\s*\}/g, '$1');
            return s;
          } catch { return String(t||''); }
        }

        // Heuristic to detect that a problem is a true word-phrase → expression translation (no algebra in stem)
        function isWordPhraseExpressionStem(stem){
          try {
            const s = String(stem||'').toLowerCase();
            const badTokens = ['simplify','equivalent','distributive','expand','factor','evaluate','solve','=','(',')','+','-','×','*','/','^',' x',' y',' n',' m'];
            if (badTokens.some(t=> s.includes(t))) return false;
            const phraseKeys = ['sum of','difference of','product of','quotient of','more than','less than','increased by','decreased by','twice','double','triple','half of','per','times the','the number'];
            return phraseKeys.some(k=> s.includes(k));
          } catch { return false; }
        }
        function latexifyInline(text){
          try {
            const t = String(text||'').trim();
            if (!t) return '$\\text{}$';
            const fixed = wrapLatexFragments(fixCommonLatexTypos(t));
            if (isProbablyLatex(fixed)) return fixed;
            // If there is any LaTeX command (including operators like \\times) or a backslash, wrap whole string in math
            if (containsLatexCommand(fixed) || /\\[a-zA-Z]+/.test(fixed)) return `$${fixed}$`;
            // If plain number, render as math number instead of \\text{}
            if (/^-?\\d+(?:\\.\\d+)?$/.test(fixed)) return `$${fixed}$`;
            return `$\\text{${latexEscapeText(fixed)}}$`;
          } catch { return '$\\text{}$'; }
        }

        function stripLatexToPlain(text){
          try {
            let s = String(text||'');
            s = s.replace(/^\s*\$\s*/, '').replace(/\s*\$\s*$/, '');
            s = s.replace(/^\\text\{([\s\S]*)\}$/i, '$1');
            s = s.replace(/^\\dfrac\{([^}]*)\}\{([^}]*)\}$/i, '$1/$2');
            // Remove degree markers like ^\circ or \degree
            s = s.replace(/\^\s*\\?circ/g, '').replace(/\\degree/g, '');
            // Remove leftover braces
            s = s.replace(/[{}]/g, '');
            s = s.replace(/\\/g, '');
            return s.trim();
          } catch { return String(text||''); }
        }
        function normalizePlain(s){
          try {
            return String(s||'').toLowerCase().replace(/\s+/g,' ').replace(/\s*,\s*/g, ',').replace(/\s*cm\b/g,' cm').trim();
          } catch { return String(s||''); }
        }
        function plainsEqualLoose(a,b){
          try {
            const na = normalizePlain(stripLatexToPlain(a));
            const nb = normalizePlain(stripLatexToPlain(b));
            if (na === nb) return true;
            const fa = parseNumberLoose(na), fb = parseNumberLoose(nb);
            if (!Number.isNaN(fa) && !Number.isNaN(fb) && Math.abs(fa - fb) < 1e-9) return true;
            return false;
          } catch { return false; }
        }

        // Fix items that ask for quadrant but refer to the origin (0,0)
        function fixQuadrantOrigin(problem){
          try {
            const stemPlain = normalizePlain(stripLatexToPlain(problem.stem||''));
            const mentionsOrigin = /(\(\s*0\s*,\s*0\s*\)|\borigin\b)/i.test(stemPlain);
            const mentionsQuadrant = /quadrant/i.test(stemPlain);
            if (!mentionsQuadrant) return problem;
            if (!mentionsOrigin) return problem;
            const opts = Array.isArray(problem.options) ? problem.options.slice(0,4).map(String) : [];
            const hasOriginChoice = opts.some(o=> /origin|none of/i.test(normalizePlain(stripLatexToPlain(o))));
            if (!hasOriginChoice){
              // Replace last option with Origin choice and set correct index
              while (opts.length < 4) opts.push('');
              const originLabel = '$\\text{Origin (none of the quadrants)}$';
              opts[3] = originLabel;
              problem.options = opts;
              problem.correct = 3;
              const note = ' The point $(0,0)$ is the origin and is not in any quadrant.';
              problem.explanation = String(problem.explanation||'') + note;
            }
            return problem;
          } catch { return problem; }
        }

        // Strict string equality (no numeric evaluation). Used for "simplify/lowest terms" tasks
        function plainsEqualStrict(a,b){
          try {
            const na = normalizePlain(stripLatexToPlain(a)).replace(/\s+/g,'');
            const nb = normalizePlain(stripLatexToPlain(b)).replace(/\s+/g,'');
            return na === nb;
          } catch { return false; }
        }

        function requiresExactOptionMatch(stem){
          try {
            const s = String(stem||'').toLowerCase();
            return (
              s.includes('simplify') ||
              s.includes('simplest form') ||
              s.includes('lowest terms') ||
              s.includes('reduce to lowest') ||
              s.includes('write as a simplified fraction') ||
              s.includes('equivalent fractions; simplifying')
            );
          } catch { return false; }
        }

        function parseNumberLoose(s){
          try {
            const t = String(s||'').replace(/,/g,'');
            // Match fraction a/b first
            const mFrac = t.match(/(-?\d+(?:\.\d+)?)\s*\/\s*(-?\d+(?:\.\d+)?)/);
            if (mFrac){
              const a = parseFloat(mFrac[1]); const b = parseFloat(mFrac[2]);
              if (!Number.isNaN(a) && !Number.isNaN(b) && b !== 0) return a/b;
            }
            const m = t.match(/-?\d+(?:\.\d+)?/);
            return m ? parseFloat(m[0]) : NaN;
          } catch { return NaN; }
        }
        function roundToDecimalPlaces(n, places){
          const f = Math.pow(10, places);
          return Math.round(n * f) / f;
        }
        function roundToIntegerPlace(n, pow10){
          // pow10: 1 -> nearest ten, 2 -> hundred, 3 -> thousand, 6 -> million, etc.
          const f = Math.pow(10, pow10);
          return Math.round(n / f) * f;
        }

        // Determine correct index for "place value of the digit d in the number N" items
        function findPlaceValueCorrectIndex(stemText, options){
          try {
            const s = String(stemText||'').toLowerCase();
            const m = s.match(/place\s+value\s+of\s+the\s+digit\s+(\d)\s+in\s+the\s+number\s+([\d,]+)/i);
            if (!m) return -1;
            const digit = m[1];
            const num = (m[2]||'').replace(/,/g,'');
            if (!/^\d+$/.test(num)) return -1;
            const idxFromRight = num.split('').reverse().findIndex(ch => ch === digit);
            if (idxFromRight < 0) return -1;
            const placeIdx = idxFromRight; // 0 ones, 1 tens, 2 hundreds, 3 thousands, ...
            const names = ['ones','tens','hundreds','thousands','ten thousands','hundred thousands','millions','ten millions','hundred millions','billions'];
            const expectedName = names[Math.min(placeIdx, names.length-1)];
            // Try to match an option to expectedName (case-insensitive, allow singular/plural)
            const norm = (t)=> String(t||'').toLowerCase().replace(/\s+/g,' ').trim();
            const target1 = expectedName;
            const target2 = expectedName.replace(/s\b/,'');
            for (let i=0;i<options.length;i++){
              const o = norm(stripLatexToPlain(options[i]));
              if (o === target1 || o === target2) return i;
            }
            return -1;
          } catch { return -1; }
        }
        function findRoundingCorrectIndex(stemText, options){
          try {
            const t = String(stemText||'').toLowerCase();
            // Accept numbers with commas
            const mDec = t.match(/round\s+([0-9][0-9,]*(?:\.[0-9]+)?)\s+to\s+the\s+nearest\s+(tenth|hundredth|thousandth)/i);
            const mInt = t.match(/round\s+([0-9][0-9,]*(?:\.[0-9]+)?)\s+to\s+the\s+nearest\s+(ten|hundred|thousand|million)/i);
            if (!mDec && !mInt) return -1;
            const raw = (mDec ? mDec[1] : mInt[1]);
            const val = parseNumberLoose(raw);
            let want = NaN;
            if (mDec){
              const placeWord = mDec[2];
              const places = placeWord.includes('thousand') ? 3 : placeWord.includes('hundred') ? 2 : 1;
              want = roundToDecimalPlaces(val, places);
            } else {
              const unit = mInt[2];
              const pow10 = unit.includes('million') ? 6 : unit.includes('thousand') ? 3 : unit.includes('hundred') ? 2 : 1;
              want = roundToIntegerPlace(val, pow10);
            }
            for (let i=0;i<options.length;i++){
              const v = parseNumberLoose(stripLatexToPlain(options[i]));
              if (!Number.isNaN(v) && Math.abs(v - want) < 1e-9) return i;
            }
            return -1;
          } catch { return -1; }
        }

        function findPerimeterRectangleCorrectIndex(stemText, options){
          try {
            const t = String(stemText||'').toLowerCase();
            const m = t.match(/perimeter\s+of\s+a\s+rectangle\s+with\s+length\s+([0-9][0-9,]*(?:\.[0-9]+)?)\s*(cm|mm|m|in|ft)?\s+and\s+width\s+([0-9][0-9,]*(?:\.[0-9]+)?)\s*(cm|mm|m|in|ft)?/i);
            if (!m) return -1;
            const L = parseNumberLoose(m[1]);
            const W = parseNumberLoose(m[3]);
            const val = 2 * (L + W);
            for (let i=0;i<options.length;i++){
              const v = parseNumberLoose(stripLatexToPlain(options[i]));
              if (!Number.isNaN(v) && Math.abs(v - val) < 1e-9) return i;
            }
            return -1;
          } catch { return -1; }
        }
        function sanitizeProblem(problem){
          try {
            if (!problem || !Array.isArray(problem.options)) return problem;
            problem = fixQuadrantOrigin(problem);
            // Stems: only wrap inline fragments to avoid double $$
            if (problem.stem) problem.stem = latexifyStem(problem.stem);
            // Ensure any remaining bare LaTeX in stem/options gets wrapped
            const rawOpts = problem.options.map(o=> String(o||'').trim());
            // Pre-normalize operator words before latexifying
            const normWordOps = (s)=> s.replace(/\b(times)\b/gi, '\\times').replace(/\b(div(?:ide|ided)?\s*by)\b/gi, '\\div');
            const opts = rawOpts.map(o=> latexifyInline(normWordOps(o)));
            // Normalize 'correct' accepting index or value
            let correctIdx = Number.isInteger(problem.correct) ? Number(problem.correct) : Number(String(problem.correct||'').trim());
            if (!(correctIdx >= 0 && correctIdx <= 3)){
              const answerValue = problem.answer || problem.ans || problem.solution || problem.correct || '';
              const plainAnswer = stripLatexToPlain(answerValue);
              // Try match against raw options first by plain text or number
              let idx = -1;
              for (let i=0;i<rawOpts.length;i++){
                const po = stripLatexToPlain(rawOpts[i]);
                if (po && plainAnswer && po.toLowerCase() === plainAnswer.toLowerCase()){ idx = i; break; }
                const n1 = parseFloat(po), n2 = parseFloat(plainAnswer);
                if (!Number.isNaN(n1) && !Number.isNaN(n2) && Math.abs(n1 - n2) < 1e-9){ idx = i; break; }
              }
              if (idx === -1){
                // Try match against latexified opts
                for (let i=0;i<opts.length;i++){
                  const po = stripLatexToPlain(opts[i]);
                  if (po && plainAnswer && po.toLowerCase() === plainAnswer.toLowerCase()){ idx = i; break; }
                }
              }
              correctIdx = (idx >= 0 && idx <= 3) ? idx : 0;
            }
            correctIdx = Math.max(0, Math.min(3, Number(correctIdx||0)));
            // Heuristic fixes: recompute expected for common numeric tasks and prefer matching option
            const stemPlain = stripLatexToPlain(problem.stem);
            const roundingIdx = findRoundingCorrectIndex(stemPlain, opts);
            if (roundingIdx >= 0) correctIdx = roundingIdx;
            const placeIdx = findPlaceValueCorrectIndex(stemPlain, opts);
            if (placeIdx >= 0) correctIdx = placeIdx;
            const periIdx = findPerimeterRectangleCorrectIndex(stemPlain, opts);
            if (periIdx >= 0) correctIdx = periIdx;
            let correctText = opts[correctIdx] || '';
            const seen = new Set();
            function mutateOptionText(text){
              let s = String(text||'');
              // numeric $123$ pattern
              const mNum = s.match(/\$\s*(-?\d+(?:\.\d+)?)\s*\$/);
              if (mNum){
                const raw = mNum[1];
                const decimals = (raw.split('.')[1]||'').length;
                let base = parseFloat(raw);
                for (let delta=1; delta<=4; delta++){
                  const cand = (base + delta).toFixed(decimals);
                  const out = `$${cand}$`;
                  if (!seen.has(out) && out !== correctText) return out;
                }
              }
              // fraction \dfrac{a}{b}
              const mFrac = s.match(/\\dfrac\{(\d+)\}\{(\d+)\}/);
              if (mFrac){
                let a = parseInt(mFrac[1],10), b = parseInt(mFrac[2],10);
                for (let delta=1; delta<=3; delta++){
                  const cand = `\\dfrac{${a+delta}}{${b}}`;
                  const out = `$${cand}$`;
                  if (!seen.has(out) && out !== correctText) return out;
                }
              }
              // coordinate (x,y)
              const mPt = s.match(/\$?\(([-\d\.]+),\s*([-\d\.]+)\)\$?/);
              if (mPt){
                let x = parseFloat(mPt[1]), y = parseFloat(mPt[2]);
                const cand = `$(${(x+1).toString()},${y})$`;
                if (!seen.has(cand) && cand !== correctText) return cand;
              }
              // fallback distinct marker (last resort)
              let attempt = s.replace(/\s+$/,'');
              for (let i=1;i<=3;i++){
                const cand = `${attempt} \;`;
                if (!seen.has(cand) && cand !== correctText) return cand;
              }
              return s;
            }
            // build unique list keeping order
            const unique = [];
            for (let i=0;i<opts.length && unique.length<4;i++){
              let t = opts[i];
              if (seen.has(t)) t = mutateOptionText(t);
              if (!seen.has(t)) { seen.add(t); unique.push(t); }
            }
            // top up to 4 using mutations from correct
            while (unique.length < 4){
              const m = mutateOptionText(correctText);
              if (!seen.has(m)) { seen.add(m); unique.push(m); } else break;
            }
            // ensure correct index points to correctText
            let newCorrect = unique.indexOf(correctText);
            if (newCorrect === -1){
              // inject correct at position 0 and adjust
              unique[0] = correctText; newCorrect = 0; seen.add(correctText);
              // keep only first 4
              if (unique.length>4) unique.length = 4;
            }
            problem.options = unique.map(u=> isProbablyLatex(u) ? u : latexifyInline(u));
            problem.correct = newCorrect;
            if (problem.explanation) problem.explanation = latexifyInline(problem.explanation);
            // also set a canonical numeric answer for robust comparison in UI if present
            try { problem.answerPlain = stripLatexToPlain(correctText); } catch {}
            return problem;
          } catch { return problem; }
        }
        function addProblems(list){
          list.forEach((p, i)=>{
            p = sanitizeProblem(p);
            const id = globalId++;
            const diff = classify(p, i);
            groups[diff].push({ p, id });
            problems.push({ p, id, diff });
          });
        }
        function availableCount(){
          return ['easy','medium','hard'].reduce((s,g)=> s + groups[g].filter(x=> !used.has(x.id)).length, 0);
        }
        function ensurePool(minNeeded){
          try {
            const need = Math.max(1, Number(minNeeded||0));
            const avail = availableCount();
            if (avail >= need) return;
            // Generate local fallback problems to guarantee supply
            const extra = fallbackProblems(lesson, Math.max(need*2, 10));
            if (Array.isArray(extra) && extra.length){ addProblems(extra); }
          } catch {}
        }
        // Detect banded lessons and prebuild a fixed ordered set of 10
        // Build ordered banded set for ALL lessons: use specific generator if present; otherwise use Gemini
        try {
          // Cache disabled per request
          // Show loading while generating questions via Gemini/local if no cache
          let loadingEl = null;
          try {
            if (!orderedProblems){
              if (window.__PS_ACTIVE_LESSON_KEY !== lessonKey) return;
              const bodyEl = document.getElementById('psBody');
              loadingEl = document.createElement('div');
              loadingEl.innerHTML = `<div class="thinking-indicator" style="display:flex;gap:6px;align-items:center;padding:12px;margin:10px 0;color:#6b3410">
                <div class="dot" style="height:7px;width:7px;border-radius:50%;background:#a57747;animation:dotPulse 1.8s ease-in-out infinite"></div>
                <div class="dot" style="height:7px;width:7px;border-radius:50%;background:#a57747;animation:dotPulse 1.8s ease-in-out infinite .1s"></div>
                <div class="dot" style="height:7px;width:7px;border-radius:50%;background:#a57747;animation:dotPulse 1.8s ease-in-out infinite .2s"></div>
                <span style="margin-left:6px">Loading…</span>
              </div>`;
              if (bodyEl) bodyEl.appendChild(loadingEl);
            }
          } catch {}
          // Prefer Gemini to generate structured problems per banding plan (block display until done or 10s timeout)
          try {
            if (!orderedProblems){
              // Fast path: use cached questions if fresh (10 minutes)
        const cached = null; // disable cache to always generate fresh problems
              if (Array.isArray(cached) && cached.length >= 10){
                orderedProblems = enforceBanding(cached.slice(0,10));
              }
            }
            if (!orderedProblems){
              // Fast lane for "Writing expressions from word phrases": synthesize locally to avoid LLM latency
              if (/writing expressions/i.test(lesson.title||'')){
                let localPool = fallbackProblems(lesson, 40);
                if (localPool && localPool.length){
                  let tenLocal = selectDiverseTen(localPool);
                  if (tenLocal && tenLocal.length){
                    const rotL = Math.floor(Math.random()*tenLocal.length);
                    if (rotL){ tenLocal = tenLocal.slice(rotL).concat(tenLocal.slice(0,rotL)); }
                    orderedProblems = enforceBanding(tenLocal);
                  }
                }
              }
            }
            if (!orderedProblems){
              const ai = await generateProblemsForLesson(course, subtopic, lesson, 18);
              if (Array.isArray(ai) && ai.length){
                if (window.__PS_ACTIVE_LESSON_KEY !== lessonKey) return;
                let pool = ai.map(p=> sanitizeProblem(p));
                let ten = selectDiverseTen(pool);
                // Randomly rotate starting item so Q1 varies between loads
                if (ten && ten.length){
                  const rot = Math.floor(Math.random()*ten.length);
                  if (rot){ ten = ten.slice(rot).concat(ten.slice(0,rot)); }
                }
                // ensure last 4 are word problems; if not, try to fetch hard word problems and reselection
                const lastFourWord = ten.slice(-4).filter(q=> isWordProblemStem(q.stem)).length;
                if (lastFourWord < 4){
                  try {
                    // require at least 2 hard-band word problems; request extra for diversity
                    const hardWord = await generateProblemsForLesson(course, subtopic, lesson, 10, { requireHardWordProblems: true });
                    if (Array.isArray(hardWord) && hardWord.length){
                      if (window.__PS_ACTIVE_LESSON_KEY !== lessonKey) return;
                      pool = pool.concat(hardWord.map(p=> sanitizeProblem(p)));
                      ten = selectDiverseTen(pool);
                      if (ten && ten.length){
                        const rot2 = Math.floor(Math.random()*ten.length);
                        if (rot2){ ten = ten.slice(rot2).concat(ten.slice(0,rot2)); }
                      }
                    }
                  } catch {}
                }
                // Top-up: ensure we have 10 by fetching extra batches if needed
                let safety = 0;
                while (ten.length < 10 && safety < 1){
                  try {
                    const extra = await generateProblemsForLesson(course, subtopic, lesson, 12);
                    if (Array.isArray(extra) && extra.length){
                      if (window.__PS_ACTIVE_LESSON_KEY !== lessonKey) return;
                      pool = pool.concat(extra.map(p=> sanitizeProblem(p)));
                      ten = selectDiverseTen(pool);
                    }
                  } catch {}
                  safety++;
                }
                // Final fallback: fill remaining with local generator if still short
                if (ten.length < 10){
                  try {
                    const need = 10 - ten.length;
                    const local = fallbackProblems(lesson, Math.max(need*2, 10));
                    pool = pool.concat(local.map(p=> sanitizeProblem(p)));
                    ten = selectDiverseTen(pool);
                  } catch {}
                }
                orderedProblems = enforceBanding(ten);
              }
            }
          } catch {}
          // No local fallback: if Gemini returns nothing in time, keep loader and show retry UI
          if (window.__PS_ACTIVE_LESSON_KEY !== lessonKey) return;
          if (!orderedProblems || orderedProblems.length === 0){
            try {
              const bodyEl = document.getElementById('psBody');
              if (bodyEl){
                const wrap = document.createElement('div');
                wrap.style.margin = '10px 0';
                const msg = document.createElement('div');
                msg.style.color = '#6b7280';
                msg.textContent = 'Generating questions (fast mode)...';
                const btn = document.createElement('button');
                btn.className = 'btn btn-secondary';
                btn.style.marginLeft = '8px';
                btn.textContent = 'Try again';
                btn.addEventListener('click', ()=> {
                  // re-run lesson load to attempt Gemini again
                  loadLesson(course.id, subtopic.id, lesson.slug);
                });
                wrap.appendChild(msg); wrap.appendChild(btn);
                bodyEl.appendChild(wrap);
              }
            } catch{}
          }
          if (window.__PS_ACTIVE_LESSON_KEY !== lessonKey) return;
          if (orderedProblems && orderedProblems.length){
            orderedProblems = makeStemsUnique(orderedProblems);
            // Save to cache for subsequent loads
            try { setCachedProblems(course, subtopic, lesson, orderedProblems); } catch {}
          }
          try { if (loadingEl && loadingEl.parentNode) loadingEl.parentNode.removeChild(loadingEl); } catch {}
        } catch {}

        // seed groups; if Gemini did not return yet, keep waiting and show retry UI
        problems = [];
        if (!orderedProblems || !orderedProblems.length){ return; }

        if (window.__PS_ACTIVE_LESSON_KEY !== lessonKey) return;
        if (orderedProblems && orderedProblems.length){
          // Remove any existing quiz container for this lesson to avoid duplicates
          const existingQuiz = document.getElementById(`ps-quiz-${course.id}-${subtopic.id}-${lesson.slug}`);
          if (existingQuiz && existingQuiz.parentNode) existingQuiz.parentNode.removeChild(existingQuiz);
          const quiz = document.createElement('div'); quiz.style.marginTop='16px';
          quiz.className = 'ps-quiz-root';
          quiz.id = `ps-quiz-${course.id}-${subtopic.id}-${lesson.slug}`;
          // Remove title and count UI per request
          const nav = document.createElement('div'); nav.style.display='none';
          const idxLabel = document.createElement('div'); idxLabel.style.display='none';

          const stage = document.createElement('div'); stage.className='ps-q-stage'; stage.innerHTML=''; quiz.appendChild(stage);
          const results = document.createElement('div'); results.style.margin='8px 0'; quiz.appendChild(results);

          let scoreBest = getProgress(`ps-best-${course.id}-${subtopic.id}-${lesson.slug}`, 0);
          let step = 0; let correctCount = 0;
          // groups and used already prepared above
          let currentDifficulty = 'easy';
          // Start a backend session to track count to 10 and display server count
          const AUTH_BASE = (window && window.TBP_AUTH_BASE) ? window.TBP_AUTH_BASE.replace(/\/$/,'') : '';
          let sessionId = null;
          try {
            const r = await fetch(`${AUTH_BASE}/ai/session/start?lesson=${encodeURIComponent(lesson.slug)}`, { method:'POST' });
            if (r.ok){ const j = await r.json(); if (j && j.ok){ sessionId = j.sessionId; if (typeof j.count === 'number'){ idxLabel.textContent = `${j.count+1} / ${j.target||10}`; } } }
          } catch {}
          async function bumpSessionCount(correct, q){
            try {
              if (!sessionId) return;
              const body = { correct: !!correct, sourceHash: (q && q.sourceHash) ? String(q.sourceHash) : undefined };
              const r = await fetch(`${AUTH_BASE}/ai/session/answer?session=${encodeURIComponent(sessionId)}`, { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify(body) });
              if (r.ok){ const j = await r.json(); if (j && typeof j.count === 'number'){ idxLabel.textContent = `${Math.min(10, j.count+1)} / 10`; } }
            } catch {}
          }

          function pickNextProblem(){
            const order = currentDifficulty==='easy' ? ['easy','medium','hard'] : (currentDifficulty==='medium' ? ['medium','easy','hard'] : ['hard','medium','easy']);
            for (const g of order){
              const pool = groups[g].filter(x=> !used.has(x.id));
              if (pool.length){
                const choice = pool[Math.floor(Math.random()*pool.length)];
                used.add(choice.id);
                return { q: choice.p, id: choice.id, g };
              }
            }
            // Fallback: if we ran out of fresh items, allow reuse to ensure we always reach 10
            for (const g of ['easy','medium','hard']){
              const any = groups[g];
              if (any && any.length){
                const choice = any[Math.floor(Math.random()*any.length)];
                return { q: choice.p, id: choice.id, g };
              }
            }
            return null;
          }

          function renderOne(){
            // helper for celebration using Lottie overlay
            function playCelebrate(){
              try {
                const wrap = document.createElement('div'); wrap.className='ps-lottie-wrap';
                const anim = document.createElement('dotlottie-wc');
                anim.setAttribute('src','https://lottie.host/d767b9fb-f462-4c1e-87e3-4dcb4747abcc/xwDsl6eHBH.lottie');
                anim.setAttribute('style','width:280px;height:280px');
                anim.setAttribute('autoplay','');
                wrap.appendChild(anim);
                document.body.appendChild(wrap);
                setTimeout(()=>{ try{ wrap.remove(); }catch{} }, 1500);
              } catch {}
            }
            // ensure single-question rendering
            stage.innerHTML = '';
            const picked = (orderedProblems && orderedPointer < orderedProblems.length) ? null : pickNextProblem();
            if (!picked){
              // If banded, advance sequentially
              if (orderedProblems && orderedPointer < orderedProblems.length){
                const q = orderedProblems[orderedPointer++];
                const card = document.createElement('div'); card.className='ps-q-card'; stage.appendChild(card);
                const stem = document.createElement('div'); stem.className='ps-stem'; stem.textContent = `${step+1}. ${q.stem}`; card.appendChild(stem);
                try { if (window.katex && window.renderMathInElement) { renderMathInElement(stem, { delimiters:[{left:"$$", right:"$$", display:true},{left:"$", right:"$", display:false},{left:"\\(", right:"\\)", display:false}], throwOnError:false }); } } catch{}
                if (q.graph){
                  const img = renderGraphAsImage(q.graph.expressions||[], 600, 280);
                  card.appendChild(img);
                }
                // Render table if provided
                if (q.table && Array.isArray(q.table.rows)){
                  const tbl = document.createElement('table');
                  tbl.style.width = '100%';
                  tbl.style.borderCollapse = 'collapse';
                  tbl.style.margin = '10px 0';
                  const addCell = (tr, tag, text)=>{
                    const el = document.createElement(tag);
                    el.textContent = String(text||'');
                    el.style.border = '1px solid #e5e7eb';
                    el.style.padding = '6px 8px';
                    tr.appendChild(el);
                  };
                  if (Array.isArray(q.table.headers) && q.table.headers.length){
                    const thead = document.createElement('thead');
                    const tr = document.createElement('tr');
                    q.table.headers.forEach(h=> addCell(tr, 'th', h));
                    thead.appendChild(tr);
                    tbl.appendChild(thead);
                  }
                  const tbody = document.createElement('tbody');
                  q.table.rows.forEach(row=>{
                    const tr = document.createElement('tr');
                    (row||[]).forEach(cell=> addCell(tr, 'td', cell));
                    tbody.appendChild(tr);
                  });
                  tbl.appendChild(tbody);
                  card.appendChild(tbl);
                }
                // Render number line if provided (avoid revealing answer via labels)
                // Hide number line for Place value; rounding & estimation
                if (q.numberLine && !/place value; rounding & estimation/i.test(String(lesson.title||''))){
                  const nl = q.numberLine;
                  const wrap = document.createElement('div');
                  wrap.style.margin = '10px 0';
                  wrap.style.height = '80px';
                  wrap.style.position = 'relative';
                  wrap.style.border = '1px solid #eee';
                  wrap.style.borderRadius = '10px';
                  card.appendChild(wrap);
                  const svgNS = 'http://www.w3.org/2000/svg';
                  const svg = document.createElementNS(svgNS, 'svg');
                  svg.setAttribute('width', '100%');
                  svg.setAttribute('height', '80');
                  wrap.appendChild(svg);
                  const pad = 24;
                  const w = wrap.clientWidth || 600;
                  const h = 80;
                  const xmin = typeof nl.min === 'number' ? nl.min : 0;
                  const xmax = typeof nl.max === 'number' ? nl.max : 10;
                  const step = typeof nl.step === 'number' ? nl.step : (xmax - xmin >= 10 ? 1 : 0.5);
                  const xmap = (x)=> pad + (w - 2*pad) * ((x - xmin) / (xmax - xmin || 1));
                  // compute numeric correct to avoid labeling it
                  let correctNum = NaN;
                  try {
                    const cidx = Math.max(0, Math.min(3, q.correct||0));
                    const ctext = (q && Array.isArray(q.options)) ? q.options[cidx] : '';
                    correctNum = parseNumberLoose(stripLatexToPlain(ctext));
                  } catch{}
                  // axis (keep visible x/y but no numeric labels to avoid revealing answers)
                  const axis = document.createElementNS(svgNS, 'line');
                  axis.setAttribute('x1', String(pad));
                  axis.setAttribute('x2', String(w - pad));
                  axis.setAttribute('y1', '40');
                  axis.setAttribute('y2', '40');
                  axis.setAttribute('stroke', '#111827');
                  axis.setAttribute('stroke-width', '2');
                  svg.appendChild(axis);
                  // ticks
                  for (let x = xmin; x <= xmax + 1e-9; x += step){
                    const X = xmap(x);
                    const t = document.createElementNS(svgNS, 'line');
                    t.setAttribute('x1', String(X)); t.setAttribute('x2', String(X));
                    t.setAttribute('y1', '35'); t.setAttribute('y2', '45');
                    t.setAttribute('stroke', '#6b7280'); svg.appendChild(t);
                    // omit numeric tick labels to reduce answer leakage
                  }
                  // axis label
                  const xl = document.createElementNS(svgNS, 'text'); xl.setAttribute('x', String(w - pad - 8)); xl.setAttribute('y', '32'); xl.setAttribute('font-size','12'); xl.textContent='x'; svg.appendChild(xl);
                  // intervals
                  (nl.intervals||[]).forEach(int=>{
                    const X1 = xmap(int.from), X2 = xmap(int.to);
                    const bar = document.createElementNS(svgNS, 'line');
                    bar.setAttribute('x1', String(X1)); bar.setAttribute('x2', String(X2));
                    bar.setAttribute('y1', '40'); bar.setAttribute('y2', '40');
                    bar.setAttribute('stroke', '#2563eb'); bar.setAttribute('stroke-width', '6'); bar.setAttribute('stroke-linecap', 'round');
                    svg.appendChild(bar);
                    // end caps open/closed
                    const cap = (X, open)=>{
                      const c = document.createElementNS(svgNS, 'circle');
                      c.setAttribute('cx', String(X)); c.setAttribute('cy', '40'); c.setAttribute('r', '5');
                      c.setAttribute('fill', open ? '#fff' : '#2563eb');
                      c.setAttribute('stroke', '#2563eb'); c.setAttribute('stroke-width', '2');
                      svg.appendChild(c);
                    };
                    cap(X1, !!int.openLeft); cap(X2, !!int.openRight);
                  });
                  // points
                  (nl.points||[]).forEach(pt=>{
                    const x = typeof pt === 'number' ? pt : pt.x;
                    const label = typeof pt === 'number' ? '' : (pt.label||'');
                    const open = typeof pt === 'number' ? false : !!pt.open;
                    const X = xmap(x);
                    const c = document.createElementNS(svgNS, 'circle');
                    c.setAttribute('cx', String(X)); c.setAttribute('cy', '40'); c.setAttribute('r', '5');
                    const nearCorrect = Number.isFinite(correctNum) && Math.abs(x - correctNum) < 1e-9;
                    const fillColor = nearCorrect ? '#fff' : (open ? '#fff' : '#10b981');
                    const strokeColor = nearCorrect ? '#9ca3af' : '#10b981';
                    c.setAttribute('fill', fillColor);
                    c.setAttribute('stroke', strokeColor); c.setAttribute('stroke-width', '2');
                    svg.appendChild(c);
                    // suppress labels to avoid revealing answers
                  });
                }
                const opts = document.createElement('div'); opts.className='ps-opts'; card.appendChild(opts);
                const order = _.shuffle(q.options.map((opt, idx)=> ({opt, idx})));
                order.forEach(pair=>{
                  const btn = document.createElement('button'); btn.type='button'; btn.className='ps-opt'; btn.innerHTML = pair.opt; btn.setAttribute('aria-pressed','false');
                  btn.dataset.idx = String(pair.idx);
                  btn.addEventListener('click', ()=>{
                    if (btn.dataset.locked==='1') return;
                    [...opts.children].forEach(ch=>{ ch.classList.remove('sel'); ch.setAttribute('aria-pressed','false'); });
                    btn.classList.add('sel'); btn.setAttribute('aria-pressed','true');
                    btn.dataset.chosen = pair.idx;
                  });
                  opts.appendChild(btn);
                });
                try { if (window.katex && window.renderMathInElement) { renderMathInElement(opts, { delimiters:[{left:"$$", right:"$$", display:true},{left:"$", right:"$", display:false},{left:"\\(", right:"\\)", display:false}], throwOnError:false }); } } catch{}
                const controls = document.createElement('div'); controls.className='ps-controls'; controls.style.display='flex'; controls.style.alignItems='center'; controls.style.justifyContent='space-between'; controls.style.gap='12px'; controls.style.marginTop='8px'; card.appendChild(controls);
                const explain = document.createElement('div'); explain.className='ps-explain'; explain.style.flex='1'; explain.style.marginRight='12px';
                const action = document.createElement('button'); action.className='btn btn-primary'; action.style.minWidth='180px'; action.style.marginTop='12px'; action.textContent='Check'; action.dataset.mode='check';
                // If a choice is selected later, revert any 'Try Again' back to 'Check'
                opts.addEventListener('click', ()=> { if (action.textContent !== 'Check') { action.textContent = 'Check'; action.dataset.mode = 'check'; } });
                async function onCheck(){
                  const chosenBtn = [...opts.children].find(ch=> ch.classList.contains('sel'));
                  if (!chosenBtn){ action.textContent='Try Again'; action.dataset.mode='check';
                    try { const toast=document.createElement('div'); toast.textContent='Please select an answer first.'; toast.setAttribute('role','status'); toast.style.position='fixed'; toast.style.top='14px'; toast.style.right='16px'; toast.style.padding='8px 12px'; toast.style.borderRadius='9999px'; toast.style.background='#b45309'; toast.style.color='#fff'; toast.style.boxShadow='0 6px 20px rgba(0,0,0,0.12)'; toast.style.zIndex='1000'; toast.style.opacity='0'; toast.style.transform='translateY(-6px)'; toast.style.transition='all .2s ease'; document.body.appendChild(toast); requestAnimationFrame(()=>{ toast.style.opacity='1'; toast.style.transform='translateY(0)'; }); setTimeout(()=>{ toast.style.opacity='0'; toast.style.transform='translateY(-6px)'; setTimeout(()=>{ try{ toast.remove(); }catch{} }, 250); }, 1200); } catch{}
                    return; }
                  const chosen = Number(chosenBtn.dataset.chosen);
                  // robust correctness: compare plain/number and also accept unit spacing
                  const chosenText = chosenBtn.textContent || chosenBtn.innerText || '';
                  // Map correct index to the actual rendered button (because options are shuffled)
                  const correctIdxNow = Math.max(0, Math.min(3, q.correct||0));
                  const correctBtn = [...opts.children].find(ch=> String(ch.dataset.idx) === String(correctIdxNow));
                  const correctRendered = correctBtn ? (correctBtn.textContent || correctBtn.innerText || '') : '';
                  const correctSource = (q && Array.isArray(q.options)) ? q.options[correctIdxNow] : '';
                  let correct = false;
                  if (requiresExactOptionMatch(q.stem)){
                    correct = (chosen === correctIdxNow) || plainsEqualStrict(chosenText, correctRendered) || plainsEqualStrict(chosenText, correctSource);
                  } else {
                    correct = (chosen === correctIdxNow) || plainsEqualLoose(chosenText, correctRendered) || plainsEqualLoose(chosenText, correctSource);
                  }
                  if (correct) { correctCount++; }
                  [...opts.children].forEach(ch=>{ ch.dataset.locked='1'; ch.disabled=true; ch.classList.add('locked'); });
                  action.dataset.mode = 'next'; action.textContent = 'Next';
                  explain.innerHTML = correct ? `<span style="color:#155e2b"><i class='bi bi-check-circle'></i> Correct.</span> ${q.explanation||''}` : `<span style=\"color:#991b1b\"><i class='bi bi-x-circle'></i> Incorrect.</span> ${q.explanation||''}`;
                  try { if (window.katex && window.renderMathInElement) { renderMathInElement(explain, { delimiters:[{left:"$$", right:"$$", display:true},{left:"$", right:"$", display:false},{left:"\\(", right:"\\)", display:false}], throwOnError:false }); } } catch{}
                  await bumpSessionCount(correct, q);
                  if (correct){
                    try {
                      const toast = document.createElement('div');
                      toast.textContent = 'Nice work!';
                      toast.style.position='fixed'; toast.style.top='14px'; toast.style.right='16px'; toast.style.padding='8px 12px'; toast.style.borderRadius='9999px'; toast.style.background='#10b981'; toast.style.color='#fff'; toast.style.boxShadow='0 6px 20px rgba(0,0,0,0.12)'; toast.style.zIndex='1000'; toast.style.opacity='0'; toast.style.transform='translateY(-6px)'; toast.style.transition='all .2s ease';
                      document.body.appendChild(toast); requestAnimationFrame(()=>{ toast.style.opacity='1'; toast.style.transform='translateY(0)'; });
                      setTimeout(()=>{ toast.style.opacity='0'; toast.style.transform='translateY(-6px)'; setTimeout(()=>{ try{ toast.remove(); }catch{} }, 250); }, 1000);
                    } catch{}
                  }
                }
                function onNext(){
                  step++;
                  if (step < 10){ idxLabel.textContent = `${step+1} / 10`; renderOne(); }
                  else { const pct = correctCount / 10; results.innerHTML = `Score: ${Math.round(pct*100)}%`; if (pct > scoreBest){ scoreBest = pct; saveProgress(`ps-best-${course.id}-${subtopic.id}-${lesson.slug}`, scoreBest); renderSidebar(); } }
                }
                action.addEventListener('click', ()=>{ if (action.dataset.mode==='next') onNext(); else onCheck(); });
                controls.appendChild(explain); controls.appendChild(action);
                return;
              }

              // try to expand pool and pick again until we have 10
              if (step < 10){
                ensurePool(10 - step);
                const retry = pickNextProblem();
                if (!retry){
                  // as a final fallback, top-up generously
                  ensurePool(20);
                }
                const retry2 = retry || pickNextProblem();
                if (!retry2){
                  const pct = correctCount / Math.max(1, step); results.innerHTML = `Score: ${Math.round(pct*100)}%`;
                  if (pct > scoreBest){ scoreBest = pct; saveProgress(`ps-best-${course.id}-${subtopic.id}-${lesson.slug}`, scoreBest); renderSidebar(); }
                  return;
                }
                // use retried pick
                used.add(retry2.id);
                const q = retry2.q; const pickedNow = retry2; // alias for downstream rendering
                const card = document.createElement('div'); card.className='ps-q-card'; stage.appendChild(card);
                const stem = document.createElement('div'); stem.className='ps-stem'; stem.textContent = `${step+1}. ${q.stem}`; card.appendChild(stem);
                try { if (window.katex && window.renderMathInElement) { renderMathInElement(stem, { delimiters:[{left:"$$", right:"$$", display:true},{left:"$", right:"$", display:false},{left:"\\(", right:"\\)", display:false}], throwOnError:false }); } } catch{}
                if (q.graph){
                  const img = renderGraphAsImage(q.graph.expressions||[], 600, 280);
                  card.appendChild(img);
                }
                // Render table if provided
                if (q.table && Array.isArray(q.table.rows)){
                  const tbl = document.createElement('table');
                  tbl.style.width = '100%';
                  tbl.style.borderCollapse = 'collapse';
                  tbl.style.margin = '10px 0';
                  const addCell = (tr, tag, text)=>{
                    const el = document.createElement(tag);
                    el.textContent = String(text||'');
                    el.style.border = '1px solid #e5e7eb';
                    el.style.padding = '6px 8px';
                    tr.appendChild(el);
                  };
                  if (Array.isArray(q.table.headers) && q.table.headers.length){
                    const thead = document.createElement('thead');
                    const tr = document.createElement('tr');
                    q.table.headers.forEach(h=> addCell(tr, 'th', h));
                    thead.appendChild(tr);
                    tbl.appendChild(thead);
                  }
                  const tbody = document.createElement('tbody');
                  q.table.rows.forEach(row=>{
                    const tr = document.createElement('tr');
                    (row||[]).forEach(cell=> addCell(tr, 'td', cell));
                    tbody.appendChild(tr);
                  });
                  tbl.appendChild(tbody);
                  card.appendChild(tbl);
                }
                // Render number line if provided
                if (q.numberLine && !/place value; rounding & estimation/i.test(String(lesson.title||''))){
                  const nl = q.numberLine;
                  const wrap = document.createElement('div');
                  wrap.style.margin = '10px 0';
                  wrap.style.height = '80px';
                  wrap.style.position = 'relative';
                  wrap.style.border = '1px solid #eee';
                  wrap.style.borderRadius = '10px';
                  card.appendChild(wrap);
                  const svgNS = 'http://www.w3.org/2000/svg';
                  const svg = document.createElementNS(svgNS, 'svg');
                  svg.setAttribute('width', '100%');
                  svg.setAttribute('height', '80');
                  wrap.appendChild(svg);
                  const pad = 24;
                  const w = wrap.clientWidth || 600;
                  const h = 80;
                  const xmin = typeof nl.min === 'number' ? nl.min : 0;
                  const xmax = typeof nl.max === 'number' ? nl.max : 10;
                  const step = typeof nl.step === 'number' ? nl.step : (xmax - xmin >= 10 ? 1 : 0.5);
                  const xmap = (x)=> pad + (w - 2*pad) * ((x - xmin) / (xmax - xmin || 1));
                  // axis
                  const axis = document.createElementNS(svgNS, 'line');
                  axis.setAttribute('x1', String(pad));
                  axis.setAttribute('x2', String(w - pad));
                  axis.setAttribute('y1', '40');
                  axis.setAttribute('y2', '40');
                  axis.setAttribute('stroke', '#374151');
                  axis.setAttribute('stroke-width', '2');
                  svg.appendChild(axis);
                  // ticks
                  for (let x = xmin; x <= xmax + 1e-9; x += step){
                    const X = xmap(x);
                    const t = document.createElementNS(svgNS, 'line');
                    t.setAttribute('x1', String(X)); t.setAttribute('x2', String(X));
                    t.setAttribute('y1', '35'); t.setAttribute('y2', '45');
                    t.setAttribute('stroke', '#6b7280'); svg.appendChild(t);
                    const lbl = document.createElementNS(svgNS, 'text');
                    lbl.setAttribute('x', String(X)); lbl.setAttribute('y', '60');
                    lbl.setAttribute('font-size', '10'); lbl.setAttribute('text-anchor', 'middle');
                    lbl.textContent = String(x);
                    svg.appendChild(lbl);
                  }
                  // intervals
                  (nl.intervals||[]).forEach(int=>{
                    const X1 = xmap(int.from), X2 = xmap(int.to);
                    const bar = document.createElementNS(svgNS, 'line');
                    bar.setAttribute('x1', String(X1)); bar.setAttribute('x2', String(X2));
                    bar.setAttribute('y1', '40'); bar.setAttribute('y2', '40');
                    bar.setAttribute('stroke', '#2563eb'); bar.setAttribute('stroke-width', '6'); bar.setAttribute('stroke-linecap', 'round');
                    svg.appendChild(bar);
                    // end caps open/closed
                    const cap = (X, open)=>{
                      const c = document.createElementNS(svgNS, 'circle');
                      c.setAttribute('cx', String(X)); c.setAttribute('cy', '40'); c.setAttribute('r', '5');
                      c.setAttribute('fill', open ? '#fff' : '#2563eb');
                      c.setAttribute('stroke', '#2563eb'); c.setAttribute('stroke-width', '2');
                      svg.appendChild(c);
                    };
                    cap(X1, !!int.openLeft); cap(X2, !!int.openRight);
                  });
                  // points
                  (nl.points||[]).forEach(pt=>{
                    const x = typeof pt === 'number' ? pt : pt.x;
                    const label = typeof pt === 'number' ? '' : (pt.label||'');
                    const open = typeof pt === 'number' ? false : !!pt.open;
                    const X = xmap(x);
                    const c = document.createElementNS(svgNS, 'circle');
                    c.setAttribute('cx', String(X)); c.setAttribute('cy', '40'); c.setAttribute('r', '5');
                    c.setAttribute('fill', open ? '#fff' : '#10b981');
                    c.setAttribute('stroke', '#10b981'); c.setAttribute('stroke-width', '2');
                    svg.appendChild(c);
                    if (label){
                      const lbl = document.createElementNS(svgNS, 'text');
                      lbl.setAttribute('x', String(X)); lbl.setAttribute('y', '24');
                      lbl.setAttribute('font-size', '10'); lbl.setAttribute('text-anchor', 'middle');
                      lbl.textContent = label;
                      svg.appendChild(lbl);
                    }
                  });
                }
                const opts = document.createElement('div'); opts.className='ps-opts'; card.appendChild(opts);
                const order = _.shuffle(q.options.map((opt, idx)=> ({opt, idx})));
                order.forEach(pair=>{
                  const btn = document.createElement('button'); btn.type='button'; btn.className='ps-opt'; btn.innerHTML = pair.opt; btn.setAttribute('aria-pressed','false');
                  btn.dataset.idx = String(pair.idx);
                  btn.addEventListener('click', ()=>{
                    if (btn.dataset.locked==='1') return;
                    [...opts.children].forEach(ch=>{ ch.classList.remove('sel'); ch.setAttribute('aria-pressed','false'); });
                    btn.classList.add('sel'); btn.setAttribute('aria-pressed','true');
                    btn.dataset.chosen = pair.idx;
                  });
                  opts.appendChild(btn);
                });
                try { if (window.katex && window.renderMathInElement) { renderMathInElement(opts, { delimiters:[{left:"$$", right:"$$", display:true},{left:"$", right:"$", display:false},{left:"\\(", right:"\\)", display:false}], throwOnError:false }); } } catch{}
                const controls = document.createElement('div'); controls.className='ps-controls'; controls.style.display='flex'; controls.style.justifyContent='flex-end'; controls.style.marginTop='22px'; card.appendChild(controls);
                const action = document.createElement('button'); action.className='btn btn-primary'; action.style.minWidth='180px'; action.textContent='Check'; action.dataset.mode='check';
                // Revert Try Again to Check when any option is selected
                opts.addEventListener('click', ()=> { if (action.textContent !== 'Check') { action.textContent = 'Check'; action.dataset.mode = 'check'; } });
                const explain = document.createElement('div'); explain.className='ps-explain';
                async function onCheck(){
                  const chosenBtn = [...opts.children].find(ch=> ch.classList.contains('sel'));
                  if (!chosenBtn){ action.textContent='Try Again'; action.dataset.mode='check';
                    try { const toast=document.createElement('div'); toast.textContent='Please select an answer first.'; toast.setAttribute('role','status'); toast.style.position='fixed'; toast.style.top='14px'; toast.style.right='16px'; toast.style.padding='8px 12px'; toast.style.borderRadius='9999px'; toast.style.background='#b45309'; toast.style.color='#fff'; toast.style.boxShadow='0 6px 20px rgba(0,0,0,0.12)'; toast.style.zIndex='1000'; toast.style.opacity='0'; toast.style.transform='translateY(-6px)'; toast.style.transition='all .2s ease'; document.body.appendChild(toast); requestAnimationFrame(()=>{ toast.style.opacity='1'; toast.style.transform='translateY(0)'; }); setTimeout(()=>{ toast.style.opacity='0'; toast.style.transform='translateY(-6px)'; setTimeout(()=>{ try{ toast.remove(); }catch{} }, 250); }, 1200); } catch{}
                    return; }
                  const chosen = Number(chosenBtn.dataset.chosen);
                  // robust correctness: compare plain/number and also accept unit spacing
                  const chosenText = chosenBtn.textContent || chosenBtn.innerText || '';
                  const correctIdxNow = Math.max(0, Math.min(3, q.correct||0));
                  const correctBtn = [...opts.children].find(ch=> String(ch.dataset.idx) === String(correctIdxNow));
                  const correctRendered = correctBtn ? (correctBtn.textContent || correctBtn.innerText || '') : '';
                  const correctSource = (q && Array.isArray(q.options)) ? q.options[correctIdxNow] : '';
                  let correct = false;
                  if (requiresExactOptionMatch(q.stem)){
                    correct = (chosen === correctIdxNow) || plainsEqualStrict(chosenText, correctRendered) || plainsEqualStrict(chosenText, correctSource);
                  } else {
                    correct = (chosen === correctIdxNow) || plainsEqualLoose(chosenText, correctRendered) || plainsEqualLoose(chosenText, correctSource);
                  }
                  if (correct) { correctCount++; }
                  [...opts.children].forEach(ch=>{ ch.dataset.locked='1'; ch.disabled=true; ch.classList.add('locked'); });
                  action.dataset.mode = 'next'; action.textContent = 'Next';
                  explain.innerHTML = correct ? `<span style="color:#155e2b"><i class='bi bi-check-circle'></i> Correct.</span> ${q.explanation||''}` : `<span style=\"color:#991b1b\"><i class='bi bi-x-circle'></i> Incorrect.</span> ${q.explanation||''}`;
                  try { if (window.katex && window.renderMathInElement) { renderMathInElement(explain, { delimiters:[{left:"$$", right:"$$", display:true},{left:"$", right:"$", display:false},{left:"\\(", right:"\\)", display:false}], throwOnError:false }); } } catch{}
                  if (correct){ currentDifficulty = currentDifficulty==='easy' ? 'medium' : (currentDifficulty==='medium' ? 'hard' : 'hard'); }
                  else { currentDifficulty = currentDifficulty==='hard' ? 'medium' : (currentDifficulty==='medium' ? 'easy' : 'easy'); }
                  await bumpSessionCount(correct, q);
                  if (correct){
                    try {
                      const toast = document.createElement('div');
                      toast.textContent = 'Nice work!';
                      toast.style.position='fixed'; toast.style.top='14px'; toast.style.right='16px'; toast.style.padding='8px 12px'; toast.style.borderRadius='9999px'; toast.style.background='#10b981'; toast.style.color='#fff'; toast.style.boxShadow='0 6px 20px rgba(0,0,0,0.12)'; toast.style.zIndex='1000'; toast.style.opacity='0'; toast.style.transform='translateY(-6px)'; toast.style.transition='all .2s ease';
                      document.body.appendChild(toast); requestAnimationFrame(()=>{ toast.style.opacity='1'; toast.style.transform='translateY(0)'; });
                      setTimeout(()=>{ toast.style.opacity='0'; toast.style.transform='translateY(-6px)'; setTimeout(()=>{ try{ toast.remove(); }catch{} }, 250); }, 1000);
                    } catch{}
                  }
                }
                function onNext(){
                  step++;
                  if (step < 10){ idxLabel.textContent = `${step+1} / 10`; renderOne(); }
                  else { const pct = correctCount / 10; results.innerHTML = `Score: ${Math.round(pct*100)}%`; if (pct > scoreBest){ scoreBest = pct; saveProgress(`ps-best-${course.id}-${subtopic.id}-${lesson.slug}`, scoreBest); renderSidebar(); } }
                }
                action.addEventListener('click', ()=>{ if (action.dataset.mode==='next') onNext(); else onCheck(); });
                controls.appendChild(action); card.appendChild(explain);
                return;
              }
              // if we already reached target length, finish
              const pct = correctCount / Math.max(1, step); results.innerHTML = `Score: ${Math.round(pct*100)}%`;
              if (pct > scoreBest){ scoreBest = pct; saveProgress(`ps-best-${course.id}-${subtopic.id}-${lesson.slug}`, scoreBest); renderSidebar(); }
              return;
            }
            const q = picked.q;
            const card = document.createElement('div'); card.className='ps-q-card'; stage.appendChild(card);
            const stem = document.createElement('div'); stem.className='ps-stem'; stem.textContent = `${step+1}. ${q.stem}`; card.appendChild(stem);
            try { if (window.katex && window.renderMathInElement) { renderMathInElement(stem, { delimiters:[{left:"$$", right:"$$", display:true},{left:"$", right:"$", display:false},{left:"\\(", right:"\\)", display:false}], throwOnError:false }); } } catch{}

            // Desmos container if graph is requested
            if (q.graph){
              const graphDiv = document.createElement('div'); graphDiv.style.height='280px'; graphDiv.style.border='1px solid #eee'; graphDiv.style.borderRadius='10px'; graphDiv.style.margin='10px 0'; card.appendChild(graphDiv);
              try {
                const calc = Desmos.GraphingCalculator(graphDiv, { expressions:false });
                const exprs = (q.graph.expressions||[]);
                const xs = []; const ys = [];
                exprs.forEach(ex => {
                  if (ex && ex.type === 'point' && typeof ex.x === 'number' && typeof ex.y === 'number'){
                    calc.setExpression({ id: ex.id || ('p'+Math.random().toString(36).slice(2)), latex: `(${ex.x},${ex.y})` });
                    xs.push(ex.x); ys.push(ex.y);
                  } else if (ex && typeof ex.latex === 'string') {
                    calc.setExpression({ id: ex.id, latex: ex.latex });
                  }
                });
                if (xs.length){
                  const minx = Math.min(...xs), maxx = Math.max(...xs);
                  const miny = Math.min(...ys), maxy = Math.max(...ys);
                  const padX = Math.max(1, (maxx - minx) || 1);
                  const padY = Math.max(1, (maxy - miny) || 1);
                  calc.setMathBounds({ left: minx - padX, right: maxx + padX, bottom: miny - padY, top: maxy + padY });
                } else {
                  calc.setMathBounds({ left: -10, right: 10, bottom: -10, top: 10 });
                }
              } catch{}
            }

            const opts = document.createElement('div'); opts.className='ps-opts'; card.appendChild(opts);
            const order = _.shuffle(q.options.map((opt, idx)=> ({opt, idx})));
            order.forEach(pair=>{
              const btn = document.createElement('button'); btn.type='button'; btn.className='ps-opt'; btn.innerHTML = latexifyInline(pair.opt); btn.setAttribute('aria-pressed','false');
              btn.dataset.idx = String(pair.idx);
              btn.addEventListener('click', ()=>{
                if (btn.dataset.locked==='1') return;
                [...opts.children].forEach(ch=>{ ch.classList.remove('sel'); ch.setAttribute('aria-pressed','false'); });
                btn.classList.add('sel'); btn.setAttribute('aria-pressed','true');
                btn.dataset.chosen = pair.idx;
              });
              opts.appendChild(btn);
            });
            try { if (window.katex && window.renderMathInElement) { renderMathInElement(opts, { delimiters:[{left:"$$", right:"$$", display:true},{left:"$", right:"$", display:false},{left:"\\(", right:"\\)", display:false}], throwOnError:false }); } } catch{}
            const controls = document.createElement('div'); controls.className='ps-controls'; controls.style.display='flex'; controls.style.justifyContent='flex-end'; controls.style.marginTop='22px'; card.appendChild(controls);
            const action = document.createElement('button'); action.className='btn btn-primary'; action.textContent='Check'; action.dataset.mode='check';
            const explain = document.createElement('div'); explain.className='ps-explain';
            action.addEventListener('click', async ()=>{
              if (action.dataset.mode==='next'){
                step++;
                if (step < 10){ idxLabel.textContent = `${step+1} / 10`; renderOne(); }
                else {
                  const pct = correctCount / 10; results.innerHTML = `Score: ${Math.round(pct*100)}%`;
                  if (pct > scoreBest){ scoreBest = pct; saveProgress(`ps-best-${course.id}-${subtopic.id}-${lesson.slug}`, scoreBest); renderSidebar(); }
                }
                return;
              }
              const chosenBtn = [...opts.children].find(ch=> ch.classList.contains('sel'));
              if (!chosenBtn){ results.textContent='Please select an answer before checking.'; results.style.color='#8B4513'; return; }
              const chosen = Number(chosenBtn.dataset.chosen);
              // robust correctness: compare plain/number and also accept unit spacing
              const chosenText = chosenBtn.textContent || '';
              const correctIdxNow = Math.max(0, Math.min(3, q.correct||0));
              const correctBtn = [...opts.children].find(ch=> String(ch.dataset.idx) === String(correctIdxNow));
              const correctRendered = correctBtn ? correctBtn.textContent : '';
              const correctSource = (q && Array.isArray(q.options)) ? q.options[correctIdxNow] : '';
                  let correct = false;
                  if (requiresExactOptionMatch(q.stem)){
                    correct = (chosen === correctIdxNow) || plainsEqualStrict(chosenText, correctRendered) || plainsEqualStrict(chosenText, correctSource);
                  } else {
                    correct = (chosen === correctIdxNow) || plainsEqualLoose(chosenText, correctRendered) || plainsEqualLoose(chosenText, correctSource);
                  }
              if (correct) { correctCount++; }
              [...opts.children].forEach(ch=>{ ch.dataset.locked='1'; ch.disabled=true; ch.classList.add('locked'); });
              action.dataset.mode='next'; action.textContent='Next question'; if (correct){ try{ playCelebrate(action); }catch{} }
              explain.innerHTML = correct ? `<span style="color:#155e2b"><i class='bi bi-check-circle'></i> Correct.</span> ${q.explanation||''}` : `<span style=\"color:#991b1b\"><i class='bi bi-x-circle'></i> Incorrect.</span> ${q.explanation||''}`;
              try { if (window.katex && window.renderMathInElement) { renderMathInElement(explain, { delimiters:[{left:"$$", right:"$$", display:true},{left:"$", right:"$", display:false},{left:"\\(", right:"\\)", display:false}], throwOnError:false }); } } catch{}
              // adapt difficulty
              if (correct){
                currentDifficulty = currentDifficulty==='easy' ? 'medium' : (currentDifficulty==='medium' ? 'hard' : 'hard');
              } else {
                currentDifficulty = currentDifficulty==='hard' ? 'medium' : (currentDifficulty==='medium' ? 'easy' : 'easy');
              }
              await bumpSessionCount(correct, q);
            });
            controls.appendChild(action); card.appendChild(explain);
          }
          idxLabel.textContent = `1 / 10`;
          renderOne();
          body.appendChild(quiz);
        }
      }

    // Tools FAB behavior and draggable windows
    (function(){
      const fab = document.getElementById('tools-fab');
      const menu = document.getElementById('tool-menu');
      function setMenu(open){ if (!menu) return; if (open) menu.classList.add('menu-open'); else menu.classList.remove('menu-open'); }
      function toggleMenu(){ if (!menu) return; menu.classList.toggle('menu-open'); }
      function closeMenu(){ setMenu(false); if (fab) fab.classList.remove('fab-open'); }
      if (fab){ fab.addEventListener('click', ()=> { toggleMenu(); fab.classList.toggle('fab-open'); }); }
      document.addEventListener('click', (e)=>{ const t=e.target; if (!t) return; if (t.closest && (t.closest('#tools-fab') || t.closest('#tool-menu'))) return; closeMenu(); });

      function makeWindow(title){
        const win = document.createElement('div'); win.className='tool-window';
        win.innerHTML = `<div class="tool-header"><span>${title}</span><div><button class="tool-close" aria-label="Close">×</button></div></div><div class="tool-body"></div>`;
        document.body.appendChild(win);
        const header = win.querySelector('.tool-header'); const closeBtn = win.querySelector('.tool-close');
        if (closeBtn) closeBtn.addEventListener('click', ()=> win.remove());
        // Drag
        let sx=0, sy=0, ox=0, oy=0, dragging=false;
        function onDown(ev){ dragging=true; sx = ev.clientX; sy = ev.clientY; const r = win.getBoundingClientRect(); ox=r.left; oy=r.top; document.addEventListener('mousemove', onMove); document.addEventListener('mouseup', onUp); }
        function onMove(ev){ if (!dragging) return; const dx=ev.clientX - sx; const dy=ev.clientY - sy; win.style.left = Math.max(8, Math.min(window.innerWidth-80, ox+dx))+'px'; win.style.top = Math.max(8, Math.min(window.innerHeight-80, oy+dy))+'px'; win.style.right='auto'; win.style.bottom='auto'; }
        function onUp(){ dragging=false; document.removeEventListener('mousemove', onMove); document.removeEventListener('mouseup', onUp); }
        if (header) header.addEventListener('mousedown', onDown);
        return win;
      }

      // Desmos
      const openDesmos = document.getElementById('open-desmos');
      if (openDesmos){ openDesmos.addEventListener('click', ()=>{
        closeMenu();
        const win = makeWindow('Desmos');
        const body = win.querySelector('.tool-body'); if (!body) return;
        function mountCalc(){
          const el = document.createElement('div'); el.id = 'calculator'; el.style.width='100%'; el.style.height='100%'; body.appendChild(el);
          try { if (window.Desmos && window.Desmos.GraphingCalculator) { window.Desmos.GraphingCalculator(el); } } catch{}
        }
        if (!(window.Desmos && window.Desmos.GraphingCalculator)){
          const api = document.createElement('script'); api.src = 'https://www.desmos.com/api/v1.11/calculator.js?apiKey=10948293c8a34275a0f7647db98602d6'; document.head.appendChild(api); api.onload = mountCalc;
        } else { mountCalc(); }
      }); }

      // TI-84
      const openTi84 = document.getElementById('open-ti84');
      if (openTi84){ openTi84.addEventListener('click', ()=>{
        closeMenu();
        const win = makeWindow('TI-84');
        const body = win.querySelector('.tool-body'); if (!body) return;
        const iframe = document.createElement('iframe'); iframe.src='https://ti84hub.com?embed=true'; iframe.width='400'; iframe.height='900'; iframe.title='TI-84 Calculator'; iframe.style.width='100%'; iframe.style.height='100%'; iframe.frameBorder='0'; body.appendChild(iframe);
      }); }

      // NumWorks (linking to project page as reference)
      const openNumworks = document.getElementById('open-numworks');
      if (openNumworks){ openNumworks.addEventListener('click', ()=>{
        closeMenu();
        const win = makeWindow('NumWorks');
        const body = win.querySelector('.tool-body'); if (!body) return;
        const link = document.createElement('a'); link.href='https://github.com/numworks/epsilon'; link.target='_blank'; link.rel='noopener'; link.textContent='Open NumWorks Epsilon';
        link.style.display='inline-block'; link.style.margin='12px'; body.appendChild(link);
      }); }

      // Study AI opens existing Study AI popup
      const openStudy = document.getElementById('open-study-ai');
      if (openStudy){ openStudy.addEventListener('click', ()=>{ closeMenu(); try { const ev = new MouseEvent('click', { bubbles:true, cancelable:true }); const target = document.querySelector('[data-open="study-ai"]'); if (target) target.dispatchEvent(ev); } catch {} }); }

      // Formula sheet simple window
      const openFormula = document.getElementById('open-formula');
      if (openFormula){ openFormula.addEventListener('click', ()=>{ closeMenu(); const win = makeWindow('Formula sheet'); const body = win.querySelector('.tool-body'); if (!body) return; const frame = document.createElement('iframe'); frame.src='https://cdn.kastatic.org/KA-shareable-data/Math%20Formula%20Sheet.pdf'; frame.style.width='100%'; frame.style.height='100%'; frame.frameBorder='0'; body.appendChild(frame); }); }

      // Notes window (simple editable)
      const openNotes = document.getElementById('open-notes');
      if (openNotes){ openNotes.addEventListener('click', ()=>{ closeMenu(); const win = makeWindow('Notes'); const body = win.querySelector('.tool-body'); if (!body) return; const ta = document.createElement('textarea'); ta.placeholder='Type your notes...'; ta.style.width='100%'; ta.style.height='100%'; ta.style.border='none'; ta.style.outline='none'; ta.style.padding='12px'; ta.value = localStorage.getItem('tbp_notes') || ''; ta.addEventListener('input', ()=> localStorage.setItem('tbp_notes', ta.value)); body.appendChild(ta); }); }
    })();

      // Generate problems: prefer Agent 2 retrieval; fallback to Gemini proxy if empty
      async function generateProblemsForLesson(course, subtopic, lesson, count, opts){
        const AUTH_BASE = (window && window.TBP_AUTH_BASE) ? window.TBP_AUTH_BASE.replace(/\/$/,'') : '';
        const endpoint = `${AUTH_BASE}/ai/generate`;
        const agent2 = `${AUTH_BASE}/ai/agent2/questions?lesson=${encodeURIComponent(lesson.slug)}&n=${Math.max(15, count||15)}`;
        const topic = `${course.title} → ${subtopic.title} → ${lesson.title}`;
        const isWritingExpr = /writing expressions/i.test(String((lesson && lesson.title) || ''));
        const sys = `You create math MC questions. Return STRICT JSON only.`;
        const nowRnd = Math.floor(Date.now()/1000);
        const nonce = `${nowRnd}-${Math.floor(Math.random()*1e9)}`;
        const guidance = lessonGuidance(course, subtopic, lesson);
        const kws = [...buildKeywords(course, subtopic, lesson), ...lessonKeywords(course, subtopic, lesson)];
        const kw = kws.join(', ');
        const banding = getBandingProgression(course, subtopic, lesson);
        function buildPrompt(n, mode){
          const reqs = [
            `Lesson: ${lesson.title}`,
            `Topic: ${topic}`,
            guidance ? `Scope: ${guidance}` : '',
            kw ? `Keywords: ${kw}` : '',
            `Make ${n} MC questions only about this lesson. 4 options (index 0-3), include explanation, tag difficulty (easy|medium|hard).`,
            banding ? `Progression (Q1-10): ${banding}` : '',
            `Diversity seed: ${nonce} (use to vary scenarios and numbers).`,
            `Use LaTeX for math (wrap text with $\\text{...}$).`,
            mode === 'hardWord' ? `All items must be real-world word problems with distinct scenarios.` : ''
          ].filter(Boolean).join('\n');
          return `Seed: ${nonce}\n${reqs}\nReturn STRICT JSON: { "problems": [ { "stem": string, "options": [string,string,string,string], "correct": number, "explanation": string, "difficulty": "easy"|"medium"|"hard" } ] }`;
        }
        function fetchWithTimeout(url, options, timeoutMs){
          const controller = new AbortController();
          const id = setTimeout(()=> controller.abort(), timeoutMs);
          return fetch(url, { ...options, signal: controller.signal }).finally(()=> clearTimeout(id));
        }
        function normalizeStemTextLocal(text){
          try { return String(text||'').toLowerCase().replace(/\$[^$]*\$/g,'$x$').replace(/-?\d+(?:\.\d+)?/g,'#').replace(/\\dfrac\{[^}]*\}\{[^}]*\}/g,'$f$').replace(/[()^*=+\\/]/g,' ').replace(/\s+/g,' ').trim(); } catch { return String(text||''); }
        }
        let probs = [];
        // Try Agent 2 fast path
        try {
          const r = await fetch(agent2, { method:'GET' });
          if (r.ok){
            const j = await r.json();
            if (j && j.ok && Array.isArray(j.questions) && j.questions.length){
              probs = j.questions.map(q=> ({
                stem: q.stem,
                options: q.options,
                correct: q.correct,
                explanation: q.solution || q.explanation || '',
                graph: q.graph && Array.isArray(q.graph.expressions) ? { expressions: q.graph.expressions } : undefined,
                table: (q.table && Array.isArray(q.table.rows)) ? { headers: Array.isArray(q.table.headers) ? q.table.headers : undefined, rows: q.table.rows } : undefined,
                numberLine: q.numberLine || undefined
              }));
            }
          }
        } catch {}
        if (probs.length >= Math.min(10, count||10)){
          return probs.slice(0, Math.max(10, count||10));
        }
        const batchSize = Math.min(6, Math.max(4, Math.ceil(count/3)));
        const numBatches = Math.max(3, Math.ceil(count / batchSize));
        // Shuffle which batch sizes we use slightly to vary output
        const jitter = (x)=> Math.max(3, Math.min(8, x + ((Math.random()<0.5)?-1:1)));
        const fastModel = isWritingExpr ? 'gemini-1.5-flash-8b' : 'gemini-1.5-flash';
        if (isWritingExpr){
          // Parallelize for higher throughput
          const parallel = Math.min(4, numBatches);
          const requests = [];
          for (let i=0; i<parallel; i++){
            const thisCount = Math.min(batchSize, count);
            const prompt = buildPrompt(thisCount, undefined);
            const body = {
              model: fastModel,
              contents:[ { role:'user', parts:[ { text: sys + "\n\n" + prompt } ] } ],
              generationConfig: { temperature: 0.3, topP: 0.8, candidateCount: 1 }
            };
            requests.push(
              fetchWithTimeout(endpoint, { method:'POST', headers:{ 'Content-Type':'application/json' }, body: JSON.stringify(body) }, 8000)
                .then(r=> r.json()).catch(()=>null)
            );
          }
          const results = await Promise.all(requests);
          for (const j of results){
            if (!j) continue;
            let txt = (((j||{}).candidates||[])[0]||{}).content; txt = (txt && txt.parts && txt.parts[0] && txt.parts[0].text) || '';
            const parsed = parseJsonFromText(txt);
            const batch = (parsed && Array.isArray(parsed.problems)) ? parsed.problems : [];
            const seen = new Set(probs.map(p=> normalizeStemTextLocal(p.stem)));
            for (const p of batch){
              const norm = normalizeStemTextLocal(p && p.stem);
              if (!seen.has(norm)) { probs.push(p); seen.add(norm); }
            }
          }
        } else {
          for (let b=0; b<numBatches && probs.length < count; b++){
            const remaining = count - probs.length;
            const thisCount = Math.min(batchSize, remaining);
            const mode = (opts && opts.requireHardWordProblems) ? 'hardWord' : undefined;
            const prompt = buildPrompt(thisCount, mode);
            const body = {
              model: fastModel,
              contents:[ { role:'user', parts:[ { text: sys + "\n\n" + prompt } ] } ],
              generationConfig: { temperature: 0.6, topP: 0.9, candidateCount: 1 }
            };
            try {
              const res = await fetchWithTimeout(endpoint, { method:'POST', headers:{ 'Content-Type':'application/json' }, body: JSON.stringify(body) }, 12000);
              const j = await res.json();
              let txt = (((j||{}).candidates||[])[0]||{}).content; txt = (txt && txt.parts && txt.parts[0] && txt.parts[0].text) || '';
              const parsed = parseJsonFromText(txt);
              const batch = (parsed && Array.isArray(parsed.problems)) ? parsed.problems : [];
              const seen = new Set(probs.map(p=> normalizeStemTextLocal(p.stem)));
              for (const p of batch){
                const norm = normalizeStemTextLocal(p && p.stem);
                if (!seen.has(norm)) { probs.push(p); seen.add(norm); }
              }
            } catch {}
          }
        }
        // Hard filter to ensure association with the actual lesson keywords
        const hardKws = lessonKeywords(course, subtopic, lesson).map(s=> String(s).toLowerCase());
        if (hardKws.length){
          const filtered = probs.filter(p=> containsAnyKeyword(p, hardKws));
          // Always enforce filtering; if too few remain, trigger strict attempt below
          probs = filtered;
        }
        // If still too few, try a second stricter attempt echoing the exact lesson title multiple times
        if (probs.length < Math.min(count, 5)){
          const strictUser = `Seed: ${nonce}-strict\nLesson: ${lesson.title}\nMake ${count} MC questions ONLY about this lesson. Keep strictly on-topic.\n${kw?`Keywords: ${kw}`:''}${/writing expressions/i.test(lesson.title||'')?`\nRULES FOR THIS LESSON: Provide a word phrase and four expression options; the correct option must be an algebraic expression with variables and operations (e.g., n+7, 2x-3, (m+5)/2). Do NOT ask to simplify or solve; do NOT produce a numeric answer.`:''}\nReturn STRICT JSON { "problems": [ { "stem": string, "options": [string,string,string,string], "correct": number, "explanation": string, "difficulty": "easy"|"medium"|"hard" } ] }`;
          const strictBody = { model: fastModel, contents:[ { role:'user', parts:[ { text: sys + "\n\n" + strictUser } ] } ] };
          const res2 = await fetch(endpoint, { method:'POST', headers:{ 'Content-Type':'application/json' }, body: JSON.stringify(strictBody) });
          const j2 = await res2.json();
          let txt2 = (((j2||{}).candidates||[])[0]||{}).content; txt2 = (txt2 && txt2.parts && txt2.parts[0] && txt2.parts[0].text) || '';
          const parsed2 = parseJsonFromText(txt2);
          const probs2 = (parsed2 && Array.isArray(parsed2.problems)) ? parsed2.problems : [];
          let probs2f = hardKws.length ? probs2.filter(p=> containsAnyKeyword(p, hardKws)) : probs2;
          // Extra guard for "writing expressions" lessons: ensure answers are expressions, not numeric
          if (/writing expressions/i.test(lesson.title||'')){
            const looksLikeExpr = (p)=>{
              try { const a = String(((p||{}).options||[])[(p||{}).correct||0]||'').toLowerCase(); return /[a-z]/.test(a) && /[+\-*/()]/.test(a); } catch { return false; }
            };
            probs2f = probs2f.filter(looksLikeExpr);
          }
          if (probs2f.length) probs = probs2f;
        }
        // Final lesson-specific filtering
        if (/writing expressions/i.test(lesson.title||'')){
          probs = probs.filter(p=> isWordPhraseExpressionStem(p.stem));
        }
        if (!probs.length) throw new Error('Bad Gemini response');
        // optional enforcement of word-problem type
        if (opts && opts.requireHardWordProblems){
          const wp = probs.filter(p=> isWordProblemStem(p && p.stem));
          if (wp.length >= Math.min(6, count)) probs = wp;
        }
        // sanitize
        return probs.slice(0, count).map(p=>({
          stem: String(p.stem||''),
          options: (p.options||[]).slice(0,4).map(String),
          correct: Number(p.correct||0),
          explanation: String(p.explanation||''),
          graph: (p.graph && Array.isArray(p.graph.expressions)) ? { expressions: p.graph.expressions } : undefined,
          table: (p.table && Array.isArray(p.table.rows)) ? { headers: Array.isArray(p.table.headers) ? p.table.headers : undefined, rows: p.table.rows } : undefined,
          numberLine: p.numberLine || undefined
        }));
      }

      

      function getGeminiKey(){
        try { if (window.TBP_GEMINI_API_KEY) return window.TBP_GEMINI_API_KEY; } catch{}
        try { const k = localStorage.getItem('tbp_gemini_key'); if (k) return k; } catch{}
        try { if (window.__TBP_GEMINI_API_KEY) return window.__TBP_GEMINI_API_KEY; } catch{}
        return '';
      }

      function lessonGuidance(course, subtopic, lesson){
        const t = `${(course&&course.title)||''} ${(subtopic&&subtopic.title)||''} ${(lesson&&lesson.title)||''}`.toLowerCase();
        if (t.includes('place value') || t.includes('rounding')) return 'Place value to millions and thousandths; rounding to given place; estimation sums/differences/products.';
        if (t.includes('integers')) return 'Integer addition, subtraction, multiplication, division; sign rules; order of operations with integers.';
        if (t.includes('absolute value')) return 'Absolute value as distance; compare integers/opposites; simple equations with |x|. Use varied real contexts (bank balances, temperatures, elevators, hiking elevations, distances). Avoid underwater/submarine/sea-level scenarios entirely; if elevation is used, include at most one elevation item.';
        if (t.includes('properties')) return 'Commutative, associative, distributive properties; simplify expressions using properties.';
        if (t.includes('divisibility') || t.includes('prime')) return 'Divisibility tests (2,3,4,5,6,9,10); prime vs composite; prime factorization; factor trees.';
        if (t.includes('gcf')) return 'Find greatest common factor by prime factors or divisors; apply to simplify expressions and fractions.';
        if (t.includes('lcm')) return 'Least common multiple by listing or prime powers; common denominators; applications.';
        if (t.includes('equivalent fractions') || t.includes('simplifying')) return 'Equivalent fractions; reduce to simplest form; generate equivalents; compare fractions.';
        if (t.includes('add/subtract fractions')) return 'Add/subtract proper/improper and mixed numbers; common denominators; simplify results.';
        if (t.includes('multiply/divide fractions')) return 'Multiply/divide fractions and mixed numbers; reciprocals; cancel common factors; applications.';
        if (t.includes('word problems') && t.includes('fraction')) return 'Fraction word problems; part‑whole; multi‑step with mixed numbers; units.';
        if (t.includes('operations with decimals')) return 'Decimal addition/subtraction/multiplication/division; place value alignment; estimation.';
        if (t.includes('convert fractions') || t.includes('decimals')) return 'Convert fractions↔decimals via division/termination/repeating; compare and order.';
        if (t.includes('percent of a number')) return 'Percent of a number; find part/whole/percent; multi‑step contexts.';
        if (t.includes('discount') || t.includes('percent change')) return 'Markup/markdown, tax, tip; percent increase/decrease; multi‑step.';
        if (t.includes('simple interest')) return 'Simple interest I=Prt; compute interest and total; units and time conversion.';
        if (t.includes('unit rate') || t.includes('ratios')) return 'Ratios, rates, unit rate; equivalent ratios; word problems; scaling.';
        if (t.includes('proportional') || t.includes('proportions')) return 'Proportional relationships; tables; constant of proportionality; solve proportions.';
        if (t.includes('scale drawings') || t.includes('maps')) return 'Scale factors; map distances; convert between actual and scaled measurements.';
        if (t.includes('variables') || t.includes('evaluating expressions')) return 'Substitute values; evaluate expressions; use order of operations.';
        if (t.includes('combining like terms')) return 'Combine like terms; coefficients; simplify multi‑term expressions; distribute then combine.';
        if (t.includes('distributive')) return 'Apply a(b+c)=ab+ac; factor simple expressions; mental math with distributive property.';
        if (t.includes('writing expressions')) return 'Translate word phrases to algebraic expressions only (no solving/evaluating). Include clear phrases like "the sum of", "difference of", "product of", "quotient of", "twice", "half of", "3 more than", "5 less than", "the number n increased by 7". Answers should be expressions with variables (e.g., n+7, 2x-3, (m+5)/2), not numeric values. Avoid unrelated topics (probability, geometry, systems).';
        if (t.includes('one-step equations')) return 'Solve one‑step linear equations with integers/fractions/decimals; check solutions.';
        if (t.includes('two-step equations')) return 'Solve two‑step linear equations; inverse operations; check solutions.';
        if (t.includes('inequalities')) return 'Solve one‑step inequalities; graph on number line; open/closed circles; test points.';
        if (t.includes('pemdas')) return 'Order of operations with integers/fractions/decimals; nested parentheses.';
        if (t.includes('integer exponents')) return 'Squares, cubes; exponent rules (intro); evaluate simple powers.';
        if (t.includes('roots')) return 'Square/cube roots conceptually; perfect squares/cubes; estimate roots.';
        if (t.includes('scientific notation')) return 'Write/interpret scientific notation; convert standard↔scientific; operations (intro).';
        if (t.includes('points, lines, angles')) return 'Angle types and measures; complementary/supplementary/vertical; compute unknowns.';
        if (t.includes('triangles') || t.includes('quadrilaterals')) return 'Classify triangles/quadrilaterals; interior angle sums; missing angles.';
        if (t.includes('perimeter & area') || t.includes('area') || t.includes('perimeter')) return 'Perimeter and area of rectangles, triangles, parallelograms, circles; composite figures.';
        if (t.includes('surface') || t.includes('volume')) return 'Surface area and volume of rectangular prisms and intro cylinders; nets.';
        if (t.includes('pythagorean')) return 'Pythagorean theorem; find missing side; simple applications on grid.';
        if (t.includes('plotting points')) return 'Plot in all quadrants; identify coordinates; reflect across axes.';
        if (t.includes('tables → graphs') || t.includes('pattern')) return 'From tables to graphs; identify linear patterns; describe rules.';
        if (t.includes('arithmetic sequences')) return 'Arithmetic sequences; common difference; nth term (intro).';
        if (t.includes('mean, median, mode')) return 'Compute mean/median/mode/range; interpret; outliers effect.';
        if (t.includes('dot plots') || t.includes('histograms') || t.includes('box plots')) return 'Create/read dot plots, histograms, box plots; compare distributions.';
        if (t.includes('theoretical') || t.includes('experimental probability')) return 'Compute simple probabilities; fractions/percents; run experiments vs theory.';
        if (t.includes('compound probability')) return 'Independent events; product rule; simple tree diagrams.';
        if (t.includes('customary') || t.includes('metric')) return 'Unit identification and conversions within systems; relative sizes.';
        if (t.includes('unit conversions') || t.includes('dimensional')) return 'Unit conversions via dimensional analysis; set up conversion factors.';
        if (t.includes('rates as "per"') || t.includes('rates as "per"')) return 'Interpret per units (mph, $/lb, etc.); compute totals and rates.';
        return 'Create varied problems matching this lesson topic with appropriate coverage.';
      }

      function buildKeywords(course, subtopic, lesson){
        const parts = [];
        try { if (course && course.title) parts.push(course.title); } catch{}
        try { if (subtopic && subtopic.title) parts.push(subtopic.title); } catch{}
        try { if (lesson && lesson.title) parts.push(lesson.title); } catch{}
        try { if (lesson && lesson.slug) parts.push(String(lesson.slug).replace(/[-_]/g,' ')); } catch{}
        return parts.map(s=> String(s).toLowerCase());
      }

      function lessonKeywords(course, subtopic, lesson){
        const title = ((lesson&&lesson.title)||'').toLowerCase();
        const st = ((subtopic&&subtopic.title)||'').toLowerCase();
        const out = [];
        if (title.includes('properties') || st.includes('expressions')){
          out.push('commutative','associative','distributive','rearrange','grouping','a(b+c)=ab+ac','ab+ac','factor','like terms','a+b=b+a','(a+b)+c=a+(b+c)');
        }
        if (title.includes('gcf') || st.includes('gcf') || title.includes('greatest common factor')){
          out.push('gcf','greatest common factor','common factor','prime factorization','gcd');
        }
        if (title.includes('lcm') || st.includes('lcm') || title.includes('least common multiple')){
          out.push('lcm','least common multiple','multiples','common multiple','prime powers');
        }
        if (title.includes('divisibility') || st.includes('divisibility') || title.includes('prime')){
          out.push('divisible by','divisibility','prime','composite','factor');
        }
        if (title.includes('unit rate') || st.includes('ratios')){
          out.push('ratio','unit rate','proportion','constant of proportionality');
        }
        if (title.includes('plot') || title.includes('coordinate')){
          out.push('quadrants','ordered pair','(x,y)','graph');
        }
        return out;
      }

      function containsAnyKeyword(problem, kws){
        const blob = `${problem.stem||''} ${(problem.explanation||'')} ${((problem.options||[]).join(' '))}`.toLowerCase();
        return kws.some(k=> blob.includes(k));
      }

      // Lightweight graph renderer (SVG -> data URL image)
      function renderGraphAsImage(expressions, width, height){
        try {
          const w = width || 420, h = height || 420; // larger square
          const exprs = Array.isArray(expressions) ? expressions : [];
          const pts = exprs.filter(e=> e && e.type==='point' && Number.isFinite(e.x) && Number.isFinite(e.y));
          let xmin = -10, xmax = 10, ymin = -10, ymax = 10;
          if (pts.length){
            const xs = pts.map(p=> p.x), ys = pts.map(p=> p.y);
            const minx = Math.min(...xs), maxx = Math.max(...xs);
            const miny = Math.min(...ys), maxy = Math.max(...ys);
            const padX = Math.max(1, (maxx - minx) || 1);
            const padY = Math.max(1, (maxy - miny) || 1);
            xmin = Math.floor(minx - padX); xmax = Math.ceil(maxx + padX);
            ymin = Math.floor(miny - padY); ymax = Math.ceil(maxy + padY);
          }
          // enforce equal aspect ratios (square units) and centered axes through origin
          const L = Math.max(Math.abs(xmin), Math.abs(xmax), Math.abs(ymin), Math.abs(ymax), 10);
          const span = Math.ceil(L);
          xmin = -span; xmax = span; ymin = -span; ymax = span;
          const pad = 32;
          const mapX = (x)=> pad + (w - 2*pad) * ((x - xmin) / (xmax - xmin || 1));
          const mapY = (y)=> (h - pad) - (h - 2*pad) * ((y - ymin) / (ymax - ymin || 1));
          function parseLatexLine(s){
            try {
              const t = String(s||'').replace(/\s+/g,'');
              if (!t) return null;
              if (/^x=/.test(t)){
                const a = parseFloat(t.slice(2)); if (!Number.isNaN(a)) return { type:'x', a };
              }
              if (/^y=/.test(t)){
                const r = t.slice(2);
                if (/^[+-]?\d*\.?\d*x([+-]\d*\.?\d+)?$/.test(r)){
                  const mPart = r.split('x')[0];
                  const bPart = r.slice(r.indexOf('x')+1) || '0';
                  let m = 1; if (mPart === '-' ) m = -1; else if (mPart === '' || mPart === '+') m = 1; else m = parseFloat(mPart);
                  const b = parseFloat(bPart) || 0;
                  return { type:'y', m, b };
                }
                if (/^[+-]?\d*\.?\d+$/.test(r)){
                  const b = parseFloat(r); return { type:'y', m:0, b };
                }
              }
            } catch{}
            return null;
          }
          // Build SVG
          let svg = `<svg xmlns="http://www.w3.org/2000/svg" width="${w}" height="${h}">`;
          // arrowhead marker
          svg += `<defs><marker id="arrow" markerWidth="8" markerHeight="8" refX="5" refY="3" orient="auto-start-reverse"><path d="M0,0 L6,3 L0,6 Z" fill="#111827"/></marker></defs>`;
          // background
          svg += `<rect x="0" y="0" width="${w}" height="${h}" fill="#ffffff"/>`;
          // axes (darker, with arrows)
          const zeroX = (xmin <= 0 && 0 <= xmax) ? mapX(0) : null;
          const zeroY = (ymin <= 0 && 0 <= ymax) ? mapY(0) : null;
          // always draw both axes centered
          const axX = mapX(0); const axY = mapY(0);
          svg += `<line x1="${axX}" y1="${pad}" x2="${axX}" y2="${h-pad}" stroke="#111827" stroke-width="2" marker-start="url(#arrow)" marker-end="url(#arrow)"/>`;
          svg += `<line x1="${pad}" y1="${axY}" x2="${w-pad}" y2="${axY}" stroke="#111827" stroke-width="2" marker-start="url(#arrow)" marker-end="url(#arrow)"/>`;
          // axis labels, avoid numeric labels to prevent answer leakage
          if (zeroY !== null) svg += `<text x="${w-pad-12}" y="${zeroY-6}" font-size="12" fill="#111827">x</text>`;
          if (zeroX !== null) svg += `<text x="${zeroX+6}" y="${pad+12}" font-size="12" fill="#111827">y</text>`;
          // no tick marks
          // draw latex lines
          exprs.forEach(e=>{
            if (e && typeof e.latex === 'string'){
              const L = parseLatexLine(e.latex);
              if (L && L.type==='y'){
                const x1 = xmin, y1 = L.m * xmin + L.b;
                const x2 = xmax, y2 = L.m * xmax + L.b;
                svg += `<line x1="${mapX(x1)}" y1="${mapY(y1)}" x2="${mapX(x2)}" y2="${mapY(y2)}" stroke="#2563eb" stroke-width="2"/>`;
              } else if (L && L.type==='x'){
                const X = mapX(L.a);
                svg += `<line x1="${X}" y1="${pad}" x2="${X}" y2="${h-pad}" stroke="#2563eb" stroke-width="2"/>`;
              }
            }
          });
          // draw points
          pts.forEach((p)=>{
            svg += `<circle cx="${mapX(p.x)}" cy="${mapY(p.y)}" r="4" fill="#10b981" stroke="#0f766e" stroke-width="1"/>`;
          });
          svg += `</svg>`;
          const img = new Image();
          img.src = 'data:image/svg+xml;utf8,' + encodeURIComponent(svg);
          // Make it square and responsive within the column
          img.style.width = '100%';
          img.style.maxWidth = `${w}px`;
          img.style.height = 'auto';
          try { img.style.aspectRatio = '1 / 1'; } catch {}
          img.style.border = '1px solid #eee';
          img.style.borderRadius = '10px';
          img.style.display = 'block';
          img.style.margin = '10px auto';
          return img;
        } catch {
          const fallback = document.createElement('div');
          fallback.textContent = 'Graph unavailable';
          fallback.style.color = '#6b7280';
          return fallback;
        }
      }

      function parseJsonFromText(t){
        if (!t) return null;
        // try fenced block
        const m = t.match(/```json\s*([\s\S]*?)```/i) || t.match(/\{[\s\S]*\}$/);
        let raw = m ? (m[1] || m[0]) : t;
        try { return JSON.parse(raw); } catch { return null; }
      }

      // Map lesson title to a Q1–Q10 banding description passed to Gemini
      function getBandingProgression(course, subtopic, lesson){
        const title = String((lesson&&lesson.title)||'').toLowerCase();
        const st = String((subtopic&&subtopic.title)||'').toLowerCase();
        // Numbers & Operations examples
        if (title.includes('place value') || title.includes('rounding')){
          return 'Q1–Q3: Identify digit values (ones/tens/hundreds/thousands); Q4–Q6: Round to nearest ten/hundred/thousand; Q7–Q8: Estimate sums or differences by rounding; Q9–Q10: Multi-step estimation with larger numbers.';
        }
        if (title.includes('integers') || st.includes('integers')){
          return 'Q1–Q3: Add/subtract small integers (same→different signs); Q4–Q6: Subtraction with negatives and simple multiplication; Q7–Q8: Multiplication/division with sign rules; Q9–Q10: Mixed multi-step integer operations.';
        }
        if (title.includes('absolute value') || title.includes('opposites')){
          return 'Q1–Q3: Identify absolute value/opposites; Q4–Q6: Evaluate simple expressions with | |; Q7–Q8: Compare/order integers using absolute value; Q9–Q10: Word problems (distance/temperature).';
        }
        if (title.includes('properties')){
          return 'Q1–Q3: Identify commutative/associative/distributive; Q4–Q6: Apply property to rewrite; Q7–Q8: Simplify using distributive; Q9–Q10: Multi-step simplify combining properties.';
        }
        if (title.includes('greatest common factor') || title.includes('gcf')){
          return 'Q1–Q3: GCF of two small numbers; Q4–Q6: GCF of two larger numbers; Q7–Q8: GCF of three numbers; Q9–Q10: Apply GCF in word problems.';
        }
        if (title.includes('least common multiple') || title.includes('lcm')){
          return 'Q1–Q3: LCM of small pairs; Q4–Q6: LCM of larger pairs; Q7–Q8: LCM of three numbers; Q9–Q10: Word problems (meeting times/cycles).';
        }
        // Fractions examples
        if (title.includes('equivalent fractions') || title.includes('simplifying')){
          return 'Q1–Q3: Identify equivalent fractions; Q4–Q6: Simplify to lowest terms; Q7–Q8: Compare unlike denominators; Q9–Q10: Multi-step simplification.';
        }
        if (title.includes('add/subtract fractions')){
          return 'Q1–Q3: Same denominators; Q4–Q6: Unlike denominators (LCM); Q7–Q8: Mixed numbers; Q9–Q10: Word problems.';
        }
        if (title.includes('multiply/divide fractions')){
          return 'Q1–Q3: Fraction × whole; Q4–Q6: Fraction × fraction; Q7–Q8: Divide fractions/mixed numbers; Q9–Q10: Word problems.';
        }
        // Decimals example
        if (st.includes('decimals') && title.includes('place value')){
          return 'Q1–Q3: Identify decimal place value; Q4–Q6: Round to tenths/hundredths; Q7–Q8: Compare/order decimals; Q9–Q10: Estimate with decimals.';
        }
        return '';
      }

      function fallbackProblems(lesson, count){
        const out = [];
        const slug = (lesson && lesson.slug || '').toLowerCase();
        function rand(a,b){ return Math.floor(Math.random()*(b-a+1))+a; }
        function choice(arr){ return arr[Math.floor(Math.random()*arr.length)]; }
        function shuffle(arr){ return arr.map(v=>({v, r:Math.random()})).sort((a,b)=>a.r-b.r).map(x=>x.v); }
        function gcd(x,y){ x=Math.abs(x); y=Math.abs(y); while(y){ const t=x%y; x=y; y=t; } return x; }
        function lcm(x,y){ return Math.abs(x*y)/gcd(x,y); }
        function isPrime(n){ if (n<2) return false; for (let p=2;p*p<=n;p++){ if(n%p===0) return false; } return true; }
        function primeFactors(n){ const f=[]; let d=2; let m=n; while(d*d<=m){ while(m%d===0){ f.push(d); m/=d; } d++; } if(m>1) f.push(m); return f; }

        // Registry of lesson-specific generators
        const gen = {
          // Absolute value & opposites — Q1–Q10 banding
          'absolute-value-opposites': (k)=>{ const arr=[]; for(let i=0;i<k;i++){
            if (i<3){
              // Q1–Q3: identify absolute value and opposites of small integers
              const a = rand(-9,9);
              if (Math.random()<0.5){
                const corr = `$${Math.abs(a)}$`;
                const opts = shuffle([corr, `$${-Math.abs(a)}$`, `$${Math.abs(a)+1}$`, '$0$']);
                arr.push({ stem:`$|${a}|$ equals …`, options:opts, correct: opts.indexOf(corr), explanation:`Absolute value is distance from 0.`, difficulty:'easy' });
              } else {
                const corr = `$${-a}$`;
                const opts = shuffle([corr, `$${a}$`, `$${a+1}$`, `$${a-1}$`]);
                arr.push({ stem:`The opposite (additive inverse) of $${a}$ is …`, options:opts, correct: opts.indexOf(corr), explanation:`Opposite of $a$ is $-a$.`, difficulty:'easy' });
              }
            } else if (i<6){
              // Q4–Q6: evaluate simple expressions with absolute value
              const a = rand(-9,9), b = rand(-5,5);
              const mode = i%3;
              if (mode===0){
                const corr = `$${Math.abs(a)+b}$`;
                const opts = shuffle([corr, `$${Math.abs(a)-b}$`, `$${-Math.abs(a)+b}$`, `$${Math.abs(a)+b+1}$`]);
                arr.push({ stem:`Evaluate $|${a}|+(${b})$`, options:opts, correct: opts.indexOf(corr), explanation:`Compute absolute value first, then add.`, difficulty:'medium' });
              } else if (mode===1){
                const corr = `$${Math.abs(a-b)}$`;
                const opts = shuffle([corr, `$${Math.abs(a)+Math.abs(b)}$`, `$${a-b}$`, `$${Math.abs(a+b)}$`]);
                arr.push({ stem:`Evaluate $|${a}-${b}|$`, options:opts, correct: opts.indexOf(corr), explanation:`Inside first, then absolute value.`, difficulty:'medium' });
              } else {
                const corr = `$${Math.abs(-a)}$`;
                const opts = shuffle([corr, `$${-a}$`, `$${a}$`, '$0$']);
                arr.push({ stem:`Evaluate $|-${a}|$`, options:opts, correct: opts.indexOf(corr), explanation:`$|-a|=|a|$.`, difficulty:'medium' });
              }
            } else if (i<8){
              // Q7–Q8: compare/order integers using absolute value
              const a = rand(-15,15), b = rand(-15,15);
              const aa = Math.abs(a), bb = Math.abs(b);
              const corr = aa>bb? `$|${a}|$` : (aa<bb? `$|${b}|$` : 'They are equal');
              const opts = shuffle([`$|${a}|$`,`$|${b}|$`,'They are equal','$0$']);
              arr.push({ stem:`Which is greater: $|${a}|$ or $|${b}|$?`, options:opts, correct: opts.indexOf(corr), explanation:`Compare distances from 0.`, difficulty:'hard' });
            } else {
              // Q9–Q10: varied word problem scenarios using absolute value
              const scenario = rand(1,6);
              if (scenario===1){
                const east = rand(2,12); const west = rand(3,15);
                const corr = `$${east+west}$`;
                const opts = shuffle([corr, `$${Math.abs(east-west)}$`, `$${east}$`, `$${west}$`]);
                arr.push({ stem:`A town is ${east} miles east of a campsite. Another is ${west} miles west. How far apart are the two towns?`, options:opts, correct: opts.indexOf(corr), explanation:`Total separation $=|${east}|+|${west}|$.`, difficulty:'hard' });
              } else if (scenario===2){
                const sea = -rand(5,50), mount = rand(100,300);
                const corr = `$${Math.abs(mount - sea)}$`;
                const opts = shuffle([corr, `$${mount+sea}$`, `$${Math.abs(sea)}$`, `$${mount}$`]);
                arr.push({ stem:`A submarine is at ${sea} meters (below sea level) and a drone is at ${mount} meters. What is the vertical distance between them?`, options:opts, correct: opts.indexOf(corr), explanation:`Distance $=|${mount} - (${sea})|$.`, difficulty:'hard' });
              } else if (scenario===3){
                const up = rand(3,15), down = rand(2,12);
                const corr = `$${up+down}$`;
                const opts = shuffle([corr, `$${Math.abs(up-down)}$`, `$${up}$`, `$${down}$`]);
                arr.push({ stem:`An elevator goes up ${up} floors, then down ${down} floors from the lobby. How many floors separate the highest and lowest points?`, options:opts, correct: opts.indexOf(corr), explanation:`Span $=|${up}|+|${down}|$.`, difficulty:'hard' });
              } else if (scenario===4){
                const y1 = rand(10,50), y2 = -rand(5,30);
                const corr = `$${Math.abs(y1 - y2)}$`;
                const opts = shuffle([corr, `$${y1+y2}$`, `$${Math.abs(y1)}$`, `$${Math.abs(y2)}$`]);
                arr.push({ stem:`A football team gained ${y1} yards on one play and lost ${Math.abs(y2)} yards on the next. What is the total change in field position between the two extremes?`, options:opts, correct: opts.indexOf(corr), explanation:`Total swing $=|${y1} - (${y2})|$.`, difficulty:'hard' });
              } else if (scenario===5){
                const t1 = -rand(1,20), t2 = rand(1,30);
                const corr = `$${Math.abs(t2 - t1)}$`;
                const opts = shuffle([corr, `$${t2+t1}$`, `$${Math.abs(t2 + t1)}$`, `$${Math.abs(t2)}$`]);
                arr.push({ stem:`Temperature changed from ${t1}\u00B0 to ${t2}\u00B0. How many degrees did it change?`, options:opts, correct: opts.indexOf(corr), explanation:`Change $=|t_2 - t_1|$.`, difficulty:'hard' });
              } else {
                const bankStart = -rand(10,80), bankEnd = rand(5,120);
                const corr = `$${Math.abs(bankEnd - bankStart)}$`;
                const opts = shuffle([corr, `$${bankEnd+bankStart}$`, `$${Math.abs(bankStart)}$`, `$${bankEnd}$`]);
                arr.push({ stem:`A bank account was overdrawn by $${Math.abs(bankStart)} and later had a balance of $${bankEnd}. What is the total change in dollars?`, options:opts, correct: opts.indexOf(corr), explanation:`Total change $=|${bankEnd} - (${bankStart})|$.`, difficulty:'hard' });
              }
            }
          } return arr; },
          // Place value; rounding & estimation (whole numbers)
          'place-value-rounding': (k)=>{ const arr=[];
            function mkNumber(len){ let s=''; for(let i=0;i<len;i++){ s += String(rand(i===0?1:0,9)); } return parseInt(s,10); }
            function placeName(idx){ const names=['ones','tens','hundreds','thousands','ten-thousands','hundred-thousands','millions']; return names[idx]||'ones'; }
            function valueAt(num, idx){ return Math.floor(num / Math.pow(10, idx)) % 10 * Math.pow(10, idx); }
            function roundTo(num, place){ if (place==='ten') return Math.round(num/10)*10; if (place==='hundred') return Math.round(num/100)*100; if (place==='thousand') return Math.round(num/1000)*1000; return num; }
            for (let i=0;i<k;i++){
              const mode = (i<3)? 'place' : (i<6? 'round' : (i<8? 'est' : 'multi'));
              if (mode==='place'){
                const len = rand(4,7); const n = mkNumber(len); const idx = rand(0, Math.min(6,len-1));
                const val = valueAt(n, idx);
                const stem = `What is the value of the digit in the ${placeName(idx)} place in $${n}$?`;
                const opts = shuffle([`$${val}$`,`$${val/10}$`,`$${val*10}$`,`$${val + Math.pow(10, idx)}$`]);
                arr.push({ stem, options:opts, correct: opts.indexOf(`$${val}$`), explanation:`${placeName(idx)} place value is ${Math.pow(10, idx)}; value is digit×place.`, difficulty:'easy' });
              } else if (mode==='round'){
                const n = rand(100, 9999); const pick = ['ten','hundred','thousand'][rand(0,2)];
                const res = roundTo(n, pick);
                const stem = `Round $${n}$ to the nearest ${pick}.`;
                const distract = pick==='ten'? 10 : pick==='hundred'? 100 : 1000;
                const opts = shuffle([`$${res}$`,`$${res + distract}$`,`$${res - distract}$`,`$${res + (distract/2)}$`]);
                arr.push({ stem, options:opts, correct: opts.indexOf(`$${res}$`), explanation:`Look at the digit to the right; 5 or more → round up.`, difficulty:'medium' });
              } else if (mode==='est'){
                const op = ['+','-'][rand(0,1)];
                let a = rand(120, 980), b = rand(20, 860);
                const place = Math.random()<0.5? 'ten' : 'hundred';
                const ar = roundTo(a, place); let br = roundTo(b, place);
                let est; if (op==='+') est = ar+br; else est = ar-br;
                const stem = `Estimate $${a}\\ ${op}\\ ${b}$ by rounding to the nearest ${place}.`;
                const opts = shuffle([`$${est}$`,`$${est + (place==='ten'?10:100)}$`,`$${Math.max(0, est - (place==='ten'?10:100))}$`,`$${est + (place==='ten'?20:200)}$`]);
                arr.push({ stem, options:opts, correct: opts.indexOf(`$${est}$`), explanation:`Round numbers first, then compute for a quick estimate.`, difficulty:'hard' });
              } else {
                const a1 = rand(500, 950), b1 = rand(200, 850), c1 = rand(100, 650);
                const place = Math.random()<0.5? 'hundred' : 'thousand';
                const ar = roundTo(a1, place), br = roundTo(b1, place), cr = roundTo(c1, place);
                const op1 = ['+','-'][rand(0,1)], op2 = ['+','-'][rand(0,1)];
                const expr = (op1==='+'? ar+br : ar-br);
                const est = (op2==='+'? expr+cr : expr-cr);
                const stem = `Estimate $( ${a1} ${op1} ${b1} ) ${op2} ${c1}$ by rounding to the nearest ${place}.`;
                const delta = place==='hundred'? 100 : 1000;
                const opts = shuffle([`$${est}$`,`$${est+delta}$`,`$${est-delta}$`,`$${est+2*delta}$`]);
                arr.push({ stem, options:opts, correct: opts.indexOf(`$${est}$`), explanation:`Round each term to ${place}, then compute.`, difficulty:'hard' });
              }
            }
            return arr;
          },

          // Place value; rounding (decimals)
          'place-value-rounding-decimals': (k)=>{ const arr=[];
            function toFixedTrim(n, d){ return Number(n).toFixed(d).replace(/0+$/,'').replace(/\.$/,''); }
            function roundDec(x, place){ const p = place==='tenths'?1: place==='hundredths'?2:3; const f = Math.pow(10, p); return Math.round(x*f)/f; }
            for (let i=0;i<k;i++){
              const mode = i<k/2? 'place' : 'round';
              if (mode==='place'){
                // value of a decimal digit
                const a = (rand(100,999))/100; // 1.00 to 9.99
                const s = a.toFixed(3); // 3 decimals
                const pos = ['tenths','hundredths','thousandths'][rand(0,2)];
                const pIdx = pos==='tenths'? 1 : pos==='hundredths'? 2 : 3;
                const d = parseInt(s.split('.')[1][pIdx-1],10);
                const val = d/Math.pow(10,pIdx);
                const stem = `In $${s}$, what is the value of the digit in the ${pos} place?`;
                const opts = shuffle([`$${toFixedTrim(val, pIdx)}$`,`$${toFixedTrim(val*10, pIdx)}$`,`$${toFixedTrim(val/10, pIdx)}$`,`$0$`]);
                arr.push({ stem, options:opts, correct: opts.indexOf(`$${toFixedTrim(val, pIdx)}$`), explanation:`${pos} corresponds to $1/10,1/100,1/1000$.`, difficulty:'medium' });
              } else {
                const x = (rand(1000,9999))/1000; // 1.000..9.999
                const pos = ['tenths','hundredths','thousandths'][rand(0,2)];
                const r = roundDec(x, pos);
                const stem = `Round $${x.toFixed(3)}$ to the nearest ${pos}.`;
                const shift = pos==='tenths'?0.1: pos==='hundredths'?0.01:0.001;
                const opts = shuffle([`$${toFixedTrim(r, pos==='tenths'?1:pos==='hundredths'?2:3)}$`,`$${toFixedTrim(r+shift, 3)}$`,`$${toFixedTrim(Math.max(0, r-shift), 3)}$`,`$${toFixedTrim(r+2*shift, 3)}$`]);
                arr.push({ stem, options:opts, correct: opts.indexOf(`$${toFixedTrim(r, pos==='tenths'?1:pos==='hundredths'?2:3)}$`), explanation:`Look at the next digit to decide up/down.`, difficulty:'hard' });
              }
            }
            return arr;
          },
          // Fraction word problems: part-of, multi-step, compare
          'fraction-word-problems': (k)=>{ const arr=[]; for(let i=0;i<k;i++){
            const mode = i<k/3? 'part' : (i<2*k/3? 'multi' : 'compare');
            if (mode==='part'){
              const a=rand(1,9), b=rand(2,10); const batches=rand(6,20); const total=(a/b)*batches; const stem=`A recipe needs $\\dfrac{${a}}{${b}}$ cup of oil per batch. How many cups are needed for ${batches} batches?`; const corr=`$${total.toFixed(2)}$`; const opts=shuffle([corr,`$${(total+0.5).toFixed(2)}$`,`$${(total-0.5).toFixed(2)}$`,`$${(total*b).toFixed(2)}$`]); arr.push({ stem, options:opts, correct: opts.indexOf(corr), explanation:`Multiply: $${batches}\\cdot \\dfrac{${a}}{${b}}=${total.toFixed(2)}$.`, difficulty:'easy' });
            } else if (mode==='multi'){
              const price=rand(8,25); const friends=rand(3,8); const shareNum=rand(1,3), shareDen=rand(3,8); const per=price/friends; const stem=`${friends} friends share pizzas equally. Each eats $\\dfrac{${shareNum}}{${shareDen}}$ of a pizza. The total cost is $${price}$. How much does each friend pay?`; const corr=`$${per.toFixed(2)}$`; const opts=shuffle([corr,`$${(per+1).toFixed(2)}$`,`$${(per-1).toFixed(2)}$`,`$${(per*2).toFixed(2)}$`]); arr.push({ stem, options:opts, correct: opts.indexOf(corr), explanation:`Equal split: $${price}/${friends}$.`, difficulty:'medium' });
            } else {
              const a=rand(1,9), b=rand(2,10), c=rand(1,9), d=rand(2,10); const left=a*d, right=c*b; const stem=`Which is larger: $\\dfrac{${a}}{${b}}$ or $\\dfrac{${c}}{${d}}$?`; const corr = left>right? `$\\dfrac{${a}}{${b}}$` : `$\\dfrac{${c}}{${d}}$`; const opts=shuffle([corr,'They are equal', left>right? `$\\dfrac{${c}}{${d}}$`:`$\\dfrac{${a}}{${b}}$`,`$${(a/b).toFixed(2)}$`]); arr.push({ stem, options:opts, correct: opts.indexOf(corr), explanation:`Compare by cross-multiplying: ${a}·${d} vs ${c}·${b}.`, difficulty:'hard' });
            }
          } return arr; },

          // Convert fractions ↔ decimals
          'convert-frac-dec': (k)=>{ const arr=[]; for(let i=0;i<k;i++){
            if (i%2===0){ const den=[2,4,5,8,10,20,25,40,50,125][rand(0,9)]; const num=rand(1,den-1); const val=(num/den).toFixed(4).replace(/0+$/,'').replace(/\.$/,''); const stem=`Convert $\\dfrac{${num}}{${den}}$ to a decimal.`; const corr=`$${val}$`; const opts=shuffle([corr,`$${(num/(den+1)).toFixed(2)}$`,`$${(num/Math.max(1,den-1)).toFixed(2)}$`,`$${(num/den+0.1).toFixed(2)}$`]); arr.push({ stem, options:opts, correct: opts.indexOf(corr), explanation:`Compute ${num}÷${den}.`, difficulty: i<k/3?'easy': i<2*k/3?'medium':'hard' }); }
            else { const choices=[0.25,0.5,0.75,0.2,0.125,0.4,0.6,0.875]; const v=choices[rand(0,choices.length-1)]; const den=1000, num=Math.round(v*den); const g=gcd(num,den); const nn=num/g, dd=den/g; const stem=`Convert $${v}$ to a fraction in simplest form.`; const corr=`$\\dfrac{${nn}}{${dd}}$`; const opts=shuffle([corr,`$\\dfrac{${nn+1}}{${dd}}$`,`$\\dfrac{${nn}}{${dd+1}}$`,`$\\dfrac{${Math.max(1,nn-1)}}{${Math.max(1,dd-1)}}$`]); arr.push({ stem, options:opts, correct: opts.indexOf(corr), explanation:`Write as $${num}/${den}$ then reduce.`, difficulty: i<k/3?'easy': i<2*k/3?'medium':'hard' }); }
          } return arr; },

          // Writing expressions from word phrases
          'writing-expressions': (k)=>{ const arr=[]; for(let i=0;i<k;i++){
            const forms=[ {p:'the sum of $x$ and 7',e:'x+7'}, {p:'5 less than $y$',e:'y-5'}, {p:'twice $x$ increased by 3',e:'2x+3'}, {p:'the product of 4 and $(y+1)$',e:'4(y+1)'}, {p:'$x$ decreased by 2 then tripled',e:'3(x-2)'} ]; const pick=forms[rand(0,forms.length-1)]; const stem=`Write an expression for: ${pick.p}.`; const corr=`$${pick.e}$`; const opts=shuffle([corr,`$${pick.e.replace('+','-')}$`,`$${pick.e.replace(/x/g,'y')}$`,`$${pick.e.replace(/\(y\+1\)/,'y+1')}$`]); arr.push({ stem, options:opts, correct: opts.indexOf(corr), explanation:`Translate operations and order carefully.`, difficulty: i<k/3?'easy': i<2*k/3?'medium':'hard' });
          } return arr; },

          // Word problems → equations/inequalities
          'word-problems-to-eq': (k)=>{ const arr=[]; for(let i=0;i<k;i++){
            const type=i%3; if (type===0){ const x=rand(3,12), t=rand(15,40); const stem=`A number $n$ plus ${x} is ${t}. Write and solve.`; const corr=`$n=${t-x}$`; const opts=shuffle([corr,`$n=${t+x}$`,`$n=${t}$`,`$n=${x}$`]); arr.push({ stem, options:opts, correct: opts.indexOf(corr), explanation:`$n+${x}=${t}$.`, difficulty:'easy' }); }
            else if (type===1){ const a=rand(2,6), d=rand(3,12); const stem=`$${a}$ less than twice a number equals ${d}. Solve.`; const n=(d+a)/2; const corr=`$n=${n}$`; const opts=shuffle([corr,`$n=${n+1}$`,`$n=${n-1}$`,`$n=${2*n}$`]); arr.push({ stem, options:opts, correct: opts.indexOf(corr), explanation:`$2n-${a}=${d}$.`, difficulty:'medium' }); }
            else { const m=rand(3,12); const stem=`Three times a number is at least ${m}. Which inequality models this?`; const corr=`$3n\\ge ${m}$`; const opts=shuffle([corr,`$3n\\le ${m}$`,`$n+3\\ge ${m}$`,`$3+n\\ge ${m}$`]); arr.push({ stem, options:opts, correct: opts.indexOf(corr), explanation:`"At least" means $\\ge$.`, difficulty:'hard' }); }
          } return arr; },

          // Square/cube roots (conceptual & estimation)
          'roots-conceptual': (k)=>{ const arr=[]; for(let i=0;i<k;i++){
            const t=i%3; if(t===0){ const n=[4,9,16,25,36,49,64,81][rand(0,7)]; const corr=`$${Math.sqrt(n)}$`; const opts=shuffle([corr,`$${Math.sqrt(n)+1}$`,`$${Math.sqrt(n)-1}$`,`$${n}$`]); arr.push({ stem:`Evaluate $\\sqrt{${n}}$.`, options:opts, correct: opts.indexOf(corr), explanation:`Perfect squares.`, difficulty:'easy' }); }
            else if(t===1){ const n=[8,27,64,125][rand(0,3)]; const corr=`$${Math.cbrt(n)}$`; const opts=shuffle([corr,`$${Math.cbrt(n)+1}$`,`$${Math.cbrt(n)-1}$`,`$${n}$`]); arr.push({ stem:`Evaluate $\\sqrt[3]{${n}}$.`, options:opts, correct: opts.indexOf(corr), explanation:`Perfect cubes.`, difficulty:'medium' }); }
            else { const n=rand(2,20); const approx=(Math.sqrt(n)).toFixed(1); const opts=shuffle([`$${approx}$`,`$${(Math.sqrt(n)+0.5).toFixed(1)}$`,`$${(Math.sqrt(n)-0.5).toFixed(1)}$`,`$${n}$`]); arr.push({ stem:`Estimate $\\sqrt{${n}}$ to one decimal place.`, options:opts, correct: 0, explanation:`Between closest squares.`, difficulty:'hard' }); }
          } return arr; },

          // Geometry foundations
          'points-lines-angles': (k)=>{ const arr=[]; for(let i=0;i<k;i++){
            const a=rand(20,70); const t=i%3; if(t===0){ const corr=`$${90-a}$`; const opts=shuffle([corr,`$${a}$`,`$${180-a}$`,`$${a+10}$`]); arr.push({ stem:`If $\\angle A$ is complementary to $\\angle B$ and $m\\angle A=${a}^\\circ$, find $m\\angle B$.`, options:opts, correct: opts.indexOf(corr), explanation:`Complementary sum $90^\\circ$.`, difficulty:'easy' }); }
            else if(t===1){ const corr=`$${180-a}$`; const opts=shuffle([corr,`$${a}$`,`$${90-a}$`,`$${a+10}$`]); arr.push({ stem:`$\\angle C$ is supplementary to $\\angle D$ with $m\\angle C=${a}^\\circ$. Find $m\\angle D$.`, options:opts, correct: opts.indexOf(corr), explanation:`Supplementary sum $180^\\circ$.`, difficulty:'medium' }); }
            else { const corr=`$${a}$`; const opts=shuffle([corr,`$${180-a}$`,`$${90-a}$`,`$${a+10}$`]); arr.push({ stem:`Vertical angles are equal. If one angle is ${a}^\\circ$, the vertical angle is …`, options:opts, correct: opts.indexOf(corr), explanation:`Vertical angles.`, difficulty:'hard' }); }
          } return arr; },
          'triangles-quadrilaterals': (k)=>{ const arr=[]; for(let i=0;i<k;i++){
            const t=i%3; if(t===0){ const a=rand(40,80), b=rand(30,70); const corr=`$${180-a-b}$`; const opts=shuffle([corr,`$${a+b}$`,`$${a}$`,`$${b}$`]); arr.push({ stem:`Triangle angles ${a}^\\circ$ and ${b}^\\circ$. Find the third angle.`, options:opts, correct: opts.indexOf(corr), explanation:`Sum $180^\\circ$.`, difficulty:'easy' }); }
            else if(t===1){ const corr='Isosceles'; const opts=shuffle([corr,'Scalene','Equilateral','Right']); arr.push({ stem:`A triangle with sides $5,5,8$ is …`, options:opts, correct: opts.indexOf(corr), explanation:`Two equal sides → isosceles.`, difficulty:'medium' }); }
            else { const corr='Parallelogram'; const opts=shuffle([corr,'Trapezoid','Kite','Rhombus']); arr.push({ stem:`Opposite sides parallel and equal describe a …`, options:opts, correct: opts.indexOf(corr), explanation:`Definition.`, difficulty:'hard' }); }
          } return arr; },
          'perimeter-area': (k)=>{ const arr=[]; for(let i=0;i<k;i++){
            const t=i%3; if(t===0){ const l=rand(3,12), w=rand(2,10); const corr=`$${2*(l+w)}$`; const opts=shuffle([corr,`$${l+w}$`,`$${l*w}$`,`$${l*l+w*w}$`]); arr.push({ stem:`Perimeter of rectangle with $l=${l}, w=${w}$.`, options:opts, correct: opts.indexOf(corr), explanation:`$2(l+w)$.`, difficulty:'easy' }); }
            else if(t===1){ const r=rand(2,9); const corr=`$${(Math.PI*r*r).toFixed(1)}$`; const opts=shuffle([corr,`$${(2*Math.PI*r).toFixed(1)}$`,`$${(Math.PI*r).toFixed(1)}$`,`$${(r*r).toFixed(1)}$`]); arr.push({ stem:`Area of circle with $r=${r}$. (Use $\\pi$)`, options:opts, correct: opts.indexOf(corr), explanation:`$A=\\pi r^2$.`, difficulty:'medium' }); }
            else { const a=rand(3,10), b=rand(3,10), h=rand(3,10); const corr=`$${((a+b)/2*h).toFixed(1)}$`; const opts=shuffle([corr,`$${(a*b).toFixed(1)}$`,`$${(a+b+h).toFixed(1)}$`,`$${(2*(a+b)).toFixed(1)}$`]); arr.push({ stem:`Area of trapezoid with bases ${a}, ${b} and height ${h}.`, options:opts, correct: opts.indexOf(corr), explanation:`$A=\\tfrac{1}{2}(a+b)h$.`, difficulty:'hard' }); }
          } return arr; },
          'surface-volume': (k)=>{ const arr=[]; for(let i=0;i<k;i++){
            if(i%2===0){ const l=rand(2,8), w=rand(2,8), h=rand(2,8); const corr=`$${l*w*h}$`; const opts=shuffle([corr,`$${2*(l*w+l*h+w*h)}$`,`$${l+w+h}$`,`$${(l*w+h).toFixed(1)}$`]); arr.push({ stem:`Volume of rectangular prism ${l}\\times${w}\\times${h}?`, options:opts, correct: opts.indexOf(corr), explanation:`$V=lwh$.`, difficulty:'medium' }); }
            else { const r=rand(2,6), h=rand(3,10); const corr=`$${(2*Math.PI*r*(r+h)).toFixed(1)}$`; const opts=shuffle([corr,`$${(Math.PI*r*r*h).toFixed(1)}$`,`$${(2*Math.PI*r*h).toFixed(1)}$`,`$${(4*Math.PI*r*r).toFixed(1)}$`]); arr.push({ stem:`Surface area of cylinder, $r=${r}, h=${h}$.`, options:opts, correct: opts.indexOf(corr), explanation:`$SA=2\\pi r(r+h)$.`, difficulty:'hard' }); }
          } return arr; },
          'pythagorean-intro': (k)=>{ const arr=[]; for(let i=0;i<k;i++){
            if(i%2===0){ const a=rand(3,9), b=rand(4,10); const c=Math.round(Math.sqrt(a*a+b*b)); const stem=`Right triangle legs ${a} and ${b}. Find hypotenuse $c$.`; const corr=`$${c}$`; const opts=shuffle([corr,`$${c+1}$`,`$${c-1}$`,`$${a+b}$`]); arr.push({ stem, options:opts, correct: opts.indexOf(corr), explanation:`$c=\\sqrt{a^2+b^2}$.`, difficulty:'medium' }); }
            else { const c=rand(5,13); const a=rand(3,9); const b=Math.round(Math.sqrt(Math.max(1,c*c-a*a))); const stem=`Right triangle with hypotenuse ${c} and leg ${a}. Find the other leg.`; const corr=`$${b}$`; const opts=shuffle([corr,`$${b+1}$`,`$${b-1}$`,`$${c-a}$`]); arr.push({ stem, options:opts, correct: opts.indexOf(corr), explanation:`$b=\\sqrt{c^2-a^2}$.`, difficulty:'hard' }); }
          } return arr; },

          // Dot plots, histograms, box plots
          'plots-hist-box': (k)=>{ const arr=[]; for(let i=0;i<k;i++){
            const t=i%3; if(t===0){ const data=[rand(1,10),rand(1,10),rand(1,10),rand(1,10),rand(1,10)].sort((a,b)=>a-b); const med=data[2]; const stem=`A box plot shows median at ${med}. What is the median?`; const corr=`$${med}$`; const opts=shuffle([corr,`$${data[1]}$`,`$${data[3]}$`,`$${(data[0]+data[4])/2}$`]); arr.push({ stem, options:opts, correct: opts.indexOf(corr), explanation:`Median is the middle value.`, difficulty:'easy' }); }
            else if(t===1){ const bin=rand(3,7); const stem=`A histogram has the tallest bar between ${bin} and ${bin+1}. Which bin has the greatest frequency?`; const corr=`$${bin}$`; const opts=shuffle([corr,`$${bin-1}$`,`$${bin+1}$`,`$${bin+2}$`]); arr.push({ stem, options:opts, correct: opts.indexOf(corr), explanation:`Tallest bar → greatest frequency.`, difficulty:'medium' }); }
            else {
              const mode=rand(2,9);
              const scenario = rand(1,3);
              let stem;
              if (scenario===1) stem=`A dot plot of quiz scores shows the most dots at ${mode}. What is the mode?`;
              else if (scenario===2) stem=`A dot plot of daily steps shows the highest stack at ${mode}k. What is the mode?`;
              else stem=`A dot plot of survey ratings has the tallest stack at ${mode}. What is the mode?`;
              const corr=`$${mode}$`; const opts=shuffle([corr,`$${mode+1}$`,`$${mode-1}$`,`$${mode+2}$`]);
              arr.push({ stem, options:opts, correct: opts.indexOf(corr), explanation:`Mode = most frequent.`, difficulty:'hard' });
            }
          } return arr; },

          // Customary & Metric units
          'customary-metric': (k)=>{ const arr=[]; const conv=[['in','ft',12],['ft','yd',3],['yd','mi',1760],['cm','m',100],['m','km',1000],['g','kg',1000],['mL','L',1000]]; for(let i=0;i<k;i++){
            const [u1,u2,f]=conv[rand(0,conv.length-1)]; const a=rand(2,500); if (i<k/2){ const ans = u1==='yd'&&u2==='mi'? +(a/1760).toFixed(3) : +(a/f).toFixed(2); const stem=`Convert $${a}\\ ${u1}$ to ${u2}.`; const corr=`$${ans}$`; const opts=shuffle([corr,`$${(ans+1)}$`,`$${(ans-1)}$`,`$${(ans*f)}$`]); arr.push({ stem, options:opts, correct: opts.indexOf(corr), explanation:`Divide by factor $${f}$.`, difficulty: i<k/3?'easy':'medium' }); } else { const ans = u1==='yd'&&u2==='mi'? a*1760 : a*f; const stem=`Convert $${a}\\ ${u2}$ to ${u1}.`; const corr=`$${ans}$`; const opts=shuffle([corr,`$${ans/f}$`,`$${ans+f}$`,`$${ans-f}$`]); arr.push({ stem, options:opts, correct: opts.indexOf(corr), explanation:`Multiply by factor $${f}$.`, difficulty:'hard' }); }
          } return arr; },
          'properties': (k)=>{ // commutative/associative/distributive
            const arr=[]; for(let i=0;i<k;i++){
              const type = i<k/3? 'comm' : i< 2*k/3? 'assoc':'dist';
              if (type==='comm'){
                const a=rand(2,9), b=rand(2,9);
                const opts = shuffle([`$${a}+${b}=${b}+${a}$`,`$${a}+( ${b}+1 )=${a}+${b}+1$`,`$${a}( ${b}+1 )=${a}b+${a}$`,`$(${a}+${b})+1=${a}+( ${b}+1 )$`]);
                arr.push({ stem:`Which equation shows the commutative property of addition?`, options:opts, correct: opts.indexOf(`$${a}+${b}=${b}+${a}$`), explanation:`Commutative: order changes, value same: $a+b=b+a$.`, difficulty: i<k/3?'easy': i<2*k/3?'medium':'hard' });
              } else if (type==='assoc'){
                const a=rand(2,9), b=rand(2,9), c=rand(2,9);
                const opts = shuffle([`$(${a}+${b})+${c}=${a}+(${b}+${c})$`,`$${a}+${b}=${b}+${a}$`,`$${a}( ${b}+${c} )=${a}b+${a}c$`,`$(${a}\cdot${b})\cdot${c}=${a}\cdot(${b}\cdot${c})$`]);
                const corr = opts.findIndex(t=> t.includes(`(${a}+${b})+${c}`)|| t.includes(`${a}\cdot(${b}\cdot${c})`));
                arr.push({ stem:`Which shows the associative property?`, options:opts, correct:corr, explanation:`Associative: grouping changes, order same.`, difficulty: i<k/3?'easy': i<2*k/3?'medium':'hard' });
              } else {
                const a=rand(2,7), b=rand(2,7), c=rand(2,7);
                const opts = shuffle([`$${a}( ${b}+${c} )=${a*b}+${a*c}$`,`$(${a}+${b})+${c}=${a}+(${b}+${c})$`,`$${a}+${b}=${b}+${a}$`,`$${a}( ${b}+${c} )=${a}+${b}+${c}$`]);
                arr.push({ stem:`Apply the distributive property to $${a}(${b}+${c})$.`, options:opts, correct: opts.indexOf(`$${a}( ${b}+${c} )=${a*b}+${a*c}$`), explanation:`Distributive: $a(b+c)=ab+ac$.`, difficulty: i<k/3?'easy': i<2*k/3?'medium':'hard' });
              }
            } return arr; },

          'prime-factorization': (k)=>{ const arr=[]; for(let i=0;i<k;i++){ const n=rand(20,150); const pf=primeFactors(n); const stem=`Prime factorization of $${n}$ is`; const corr = `$${pf.map(p=>p).join('\n\cdot ')}$`.replace(/\n/g,''); const opts = shuffle([corr,`$${n}$`,`$${pf.join('+')}$`,`$${pf.join('-')}$`]); arr.push({ stem, options:opts, correct: opts.indexOf(corr), explanation:`Factor until primes: $${corr}$.`, difficulty: i<k/3?'easy': i<2*k/3?'medium':'hard' }); } return arr; },

          'gcf': (k)=>{ const arr=[]; for(let i=0;i<k;i++){
            function gcdN(vals){ return vals.reduce((s,x)=>gcd(s,x)); }
            function pickBase(which){
              // Encourage non-trivial, sometimes double-digit GCF
              const small=[2,3,4,5,6,7,8,9];
              const medium=[10,12,14,15,16,18];
              const large=[20,21,22,24];
              if (which==='easy') return Math.random()<0.35? medium[rand(0,medium.length-1)] : small[rand(0,small.length-1)];
              if (which==='medium') return Math.random()<0.55? medium[rand(0,medium.length-1)] : small[rand(0,small.length-1)];
              return Math.random()<0.65? large[rand(0,large.length-1)] : medium[rand(0,medium.length-1)];
            }
            function makeSet(cnt, diff){
              const base = pickBase(diff);
              // Choose distinct multipliers with gcd 1 to keep overall GCF exactly 'base'
              let mults=[]; let tries=0;
              while(tries++<80){
                const bag = new Set();
                while (bag.size < cnt){ bag.add(rand(2,12)); }
                mults = Array.from(bag);
                if (gcdN(mults)===1) break;
              }
              const nums = mults.map(m=> base*m);
              return { nums, ans: base };
            }
            if (i < k/3){
              const { nums, ans } = makeSet(2,'easy');
              const [a,b] = nums;
              const opts = shuffle([ans, ans+rand(1,4), Math.max(ans-rand(1,4),2), ans*2]).map(v=>`$${v}$`);
              arr.push({ stem:`Find $\\operatorname{GCF}(${a},${b})$.`, options:opts, correct: opts.indexOf(`$${ans}$`), explanation:`Common factor constructed: $${a}= ${ans}\cdot${a/ans},\ ${b}= ${ans}\cdot${b/ans}$.`, difficulty:'easy' });
            } else if (i < 2*k/3){
              const { nums, ans } = makeSet(3,'medium');
              const [a,b,c] = nums;
              const opts = shuffle([ans, ans+rand(2,8), Math.max(ans-rand(1,6),2), ans*2]).map(v=>`$${v}$`);
              arr.push({ stem:`Find $\\operatorname{GCF}(${a},${b},${c})$.`, options:opts, correct: opts.indexOf(`$${ans}$`), explanation:`Each shares base factor $${ans}$.`, difficulty:'medium' });
            } else {
              const { nums, ans } = makeSet(4,'hard');
              const [a,b,c,d] = nums;
              const opts = shuffle([ans, ans+rand(3,10), Math.max(ans-rand(2,8),2), ans*2]).map(v=>`$${v}$`);
              arr.push({ stem:`Find $\\operatorname{GCF}(${a},${b},${c},${d})$.`, options:opts, correct: opts.indexOf(`$${ans}$`), explanation:`Use pairwise gcd or prime factors; exact GCF is $${ans}$.`, difficulty:'hard' });
            }
          } return arr; },

          'lcm': (k)=>{
            const arr=[];
            function choicesOf(correct){
              const c = correct;
              const near = Math.max(1, c - rand(1, Math.max(2, Math.floor(c*0.25))));
              const up = c + rand(1, Math.max(2, Math.floor(c*0.25)));
              const half = Math.max(1, Math.floor(c/2));
              const doubled = c*2;
              return shuffle([c, up, near, doubled, half]).slice(0,4).map(v=>`$${v}$`);
            }
            function lcm3(a,b,c){ return lcm(lcm(a,b), c); }
            for(let i=0;i<k;i++){
              const mode = (i < Math.floor(k/3)) ? 'easy' : (i < Math.floor(2*k/3) ? 'medium' : 'hard');
              if (mode === 'easy'){
                // Small numbers with shared factors
                const base = rand(2,8); const a = base * rand(1,3); const b = base * rand(1,3);
                const ans = lcm(a,b);
                const opts = choicesOf(ans);
                arr.push({ stem:`Find $\\operatorname{LCM}(${a},${b})$.`, options:opts, correct: opts.indexOf(`$${ans}$`), explanation:`Use prime powers or multiples; $\\mathrm{lcm}(a,b)=\\dfrac{ab}{\\gcd(a,b)}=${ans}$.`, difficulty:'easy' });
              } else if (mode === 'medium'){
                // Larger numbers that require prime powers
                const a = rand(9,20); const b = rand(12,30);
                const ans = lcm(a,b);
                const opts = choicesOf(ans);
                arr.push({ stem:`Compute $\\operatorname{LCM}(${a},${b})$.`, options:opts, correct: opts.indexOf(`$${ans}$`), explanation:`Factor to primes; take highest powers.`, difficulty:'medium' });
              } else {
                if (i % 2 === 0){
                  // Three-number LCM
                  const a = rand(4,15), b = rand(6,20), c = rand(5,18);
                  const ans = lcm3(a,b,c);
                  const opts = choicesOf(ans);
                  arr.push({ stem:`Find $\\operatorname{LCM}(${a},${b},${c})$.`, options:opts, correct: opts.indexOf(`$${ans}$`), explanation:`$\\mathrm{lcm}(a,b,c)=\\mathrm{lcm}(\\mathrm{lcm}(a,b),c)=${ans}$.`, difficulty:'hard' });
                } else {
                  // Word problem (meeting cycles)
                  const a = [6,8,9,10,12,14,15,18,20][rand(0,8)];
                  const b = [7,9,10,12,16,18,21,24,30][rand(0,8)];
                  const ans = lcm(a,b);
                  const opts = choicesOf(ans);
                  arr.push({ stem:`Train A arrives every ${a} minutes and Train B every ${b} minutes. In how many minutes will they arrive together again?`, options:opts, correct: opts.indexOf(`$${ans}$`), explanation:`Synchronizing cycles occurs at $\\mathrm{LCM}(${a},${b})=${ans}$ minutes.`, difficulty:'hard' });
                }
              }
            }
            return arr;
          },

          'equivalent-simplifying': (k)=>{ const arr=[]; for(let i=0;i<k;i++){ const a=rand(2,12), b=a*rand(2,10); const g=gcd(b,a); const num=b/g, den=a/g; const opts=shuffle([`$\\dfrac{${num}}{${den}}$`,`$\\dfrac{${num+1}}{${den}}$`,`$\\dfrac{${num}}{${den+1}}$`,`$\\dfrac{${num-1}}{${den-1}}$`]); arr.push({ stem:`Simplify $\\dfrac{${b}}{${a}}$.`, options:opts, correct: opts.indexOf(`$\\dfrac{${num}}{${den}}$`), explanation:`Divide numerator and denominator by GCF.`, difficulty: i<k/3?'easy': i<2*k/3?'medium':'hard' }); } return arr; },

          'add-subtract-fractions': (k)=>{ const arr=[]; for(let i=0;i<k;i++){ const a=rand(1,9), b=rand(2,9), c=rand(1,9), d=rand(2,9); const stem = i%2===0? `$\\dfrac{${a}}{${b}}+\\dfrac{${c}}{${d}}$`:`$\\dfrac{${a}}{${b}}-\\dfrac{${c}}{${d}}$`; const num = i%2===0? a*d + c*b : a*d - c*b; const den=b*d; const g=gcd(Math.abs(num),den); const snum=num/g, sden=den/g; const corr = `$\\dfrac{${snum}}{${sden}}$`; const opts=shuffle([corr,`$\\dfrac{${snum+1}}{${sden}}$`,`$\\dfrac{${snum}}{${sden+1}}$`,`$\\dfrac{${snum-1}}{${sden-1}}$`]); arr.push({ stem:`Compute ${stem}.`, options:opts, correct: opts.indexOf(corr), explanation:`Common denominator $${den}$; simplify.`, difficulty: i<k/3?'easy': i<2*k/3?'medium':'hard' }); } return arr; },

          'multiply-divide-fractions': (k)=>{ const arr=[]; for(let i=0;i<k;i++){ const a=rand(1,9), b=rand(2,9), c=rand(1,9), d=rand(2,9); const mult = i%2===0; const stem = mult? `$\\dfrac{${a}}{${b}}\\cdot\\dfrac{${c}}{${d}}$`:`$\\dfrac{${a}}{${b}}\\div\\dfrac{${c}}{${d}}$`; const num = mult? a*c : a*d; const den = mult? b*d : b*c; const g=gcd(num,den); const corr=`$\\dfrac{${num/g}}{${den/g}}$`; const opts = shuffle([corr,`$\\dfrac{${num/g+1}}{${den/g}}$`,`$\\dfrac{${num/g}}{${den/g+1}}$`,`$\\dfrac{${num/g-1}}{${den/g-1}}$`]); arr.push({ stem:`Compute ${stem}.`, options:opts, correct: opts.indexOf(corr), explanation:`Multiply (or invert & multiply), then simplify.`, difficulty: i<k/3?'easy': i<2*k/3?'medium':'hard' }); } return arr; },

          'convert-percent': (k)=>{ const arr=[]; for(let i=0;i<k;i++){ const p=rand(5,95); const corr = `$${(p/100).toFixed(2)}$`; const opts=shuffle([corr,`$${p}$`,`$${p*100}$`,`$${(100/p).toFixed(2)}$`]); arr.push({ stem:`Convert $${p}\\%$ to a decimal.`, options:opts, correct: opts.indexOf(corr), explanation:`Divide by $100$.`, difficulty: i<k/3?'easy': i<2*k/3?'medium':'hard' }); } return arr; },
          'percent-of-number': (k)=>{ const arr=[]; for(let i=0;i<k;i++){ const p=rand(5,80), n=rand(20,200); const ans = Math.round(n*p)/100; const corr=`$${ans}$`; const opts=shuffle([corr,`$${(ans+5)}$`,`$${(ans-5)}$`,`$${(ans*2)}$`]); arr.push({ stem:`Find $${p}\\%$ of $${n}$.`, options:opts, correct: opts.indexOf(corr), explanation:`$${p}\\%=\\dfrac{${p}}{100}$; multiply by ${n}.`, difficulty: i<k/3?'easy': i<2*k/3?'medium':'hard' }); } return arr; },
          'discount-tax-tip-change': (k)=>{ const arr=[]; for(let i=0;i<k;i++){ const price=rand(20,200); const rate=[5,8,10,12,15,20][rand(0,5)]; const type=choice(['discount','tax','tip','percent change']); let stem, ans; if (type==='discount'){ stem=`A $${price}$ item has a ${rate}\\% discount. Find the sale price.`; ans = +(price*(1-rate/100)).toFixed(2);} else if (type==='tax'){ stem=`A $${price}$ item has ${rate}\\% sales tax. Find the total price.`; ans = +(price*(1+rate/100)).toFixed(2);} else if (type==='tip'){ stem=`A bill of $${price}$ with a ${rate}\\% tip. Find the total.`; ans = +(price*(1+rate/100)).toFixed(2);} else { const newP=rand(10,300); stem=`From $${price}$ to $${newP}$: percent change?`; ans = +((newP-price)/price*100).toFixed(1);} const corr=`$${ans}$`; const opts=shuffle([corr,`$${(ans+5)}$`,`$${(ans-5)}$`,`$${(ans*2)}$`]); arr.push({ stem, options:opts, correct: opts.indexOf(corr), explanation:`Apply percent formula.`, difficulty: i<k/3?'easy': i<2*k/3?'medium':'hard' }); } return arr; },

          'simple-interest-intro': (k)=>{ const arr=[]; for(let i=0;i<k;i++){ const P=rand(100,1000), r=[0.03,0.04,0.05][rand(0,2)], t=rand(1,5); const I=+(P*r*t).toFixed(2); const A=+(P+I).toFixed(2); const kind=i%2===0; const corr= kind? `$${I}$`:`$${A}$`; const opts=shuffle([corr,`$${(I+10).toFixed(2)}$`,`$${(A+10).toFixed(2)}$`,`$${(P).toFixed(2)}$`]); arr.push({ stem: kind? `Find simple interest $I$ for $P=${P}$, $r=${(r*100)}\\%$, $t=${t}$ yrs.`:`Find amount $A$ after $t=${t}$ yrs at $${(r*100)}\\%$ on $P=${P}$.`, options:opts, correct: opts.indexOf(corr), explanation:`$I=Prt$, $A=P+I$.`, difficulty: i<k/3?'easy': i<2*k/3?'medium':'hard' }); } return arr; },

          'ratios-unit-rate': (k)=>{ const arr=[]; for(let i=0;i<k;i++){ const a=rand(2,20), b=rand(2,10); const unit=(a/b).toFixed(2); const corr=`$${unit}$`; const opts=shuffle([corr,`$${(a/(b+1)).toFixed(2)}$`,`$${(a/(b-1)).toFixed(2)}$`,`$${(a*b).toFixed(2)}$`]); arr.push({ stem:`Unit rate of $${a}$ for $${b}$ units?`, options:opts, correct: opts.indexOf(corr), explanation:`Divide: $a/b$.`, difficulty: i<k/3?'easy': i<2*k/3?'medium':'hard' }); } return arr; },
          'proportional-relationships': (k)=>{ const arr=[]; for(let i=0;i<k;i++){ const k0=rand(2,9); const x=rand(2,12); const y=k0*x; const corr=`$${k0}$`; const opts=shuffle([corr,`$${k0+1}$`,`$${k0-1}$`,`$${k0+2}$`]); arr.push({ stem:`If $y=kx$ and $(x,y)=(${x},${y})$, find $k$.`, options:opts, correct: opts.indexOf(corr), explanation:`$k=y/x=${y}/${x}=${k0}$.`, difficulty: i<k/3?'easy': i<2*k/3?'medium':'hard' }); } return arr; },
          'scale-drawings': (k)=>{ const arr=[]; for(let i=0;i<k;i++){ const scale=`1:${choice([2,3,4,5,10])}`; const d=rand(3,20); const s=parseInt(scale.split(':')[1]); const ans=d*s; const corr=`$${ans}$`; const opts=shuffle([corr,`$${ans+s}$`,`$${ans-s}$`,`$${d}$`]); arr.push({ stem:`Scale ${scale}. If drawing length is $${d}$ cm, actual length?`, options:opts, correct: opts.indexOf(corr), explanation:`Multiply by scale factor ${s}.`, difficulty: i<k/3?'easy': i<2*k/3?'medium':'hard' }); } return arr; },
          'constant-of-prop': (k)=>{ const arr=[]; for(let i=0;i<k;i++){ const k0=rand(2,9); const x=rand(2,12); const y=k0*x; const corr=`$y= ${k0}x$`; const opts=shuffle([corr,`$y=${k0+x}$`,`$y=${k0}x+1$`,`$y=\\dfrac{x}{${k0}}$`]); arr.push({ stem:`Find the constant of proportionality and equation through $(0,0)$ and $(${x},${y})$.`, options:opts, correct: opts.indexOf(corr), explanation:`$k=y/x=${k0}$ so $y=kx$.`, difficulty: i<k/3?'easy': i<2*k/3?'medium':'hard' }); } return arr; },

          'variables-evaluating': (k)=>{ const arr=[]; for(let i=0;i<k;i++){ const a=rand(1,6), b=rand(1,6), x=rand(1,6); const expr = i%2? `${a}x+${b}`:`${a}x-${b}`; const ans = i%2? a*x+b : a*x-b; const corr=`$${ans}$`; const opts=shuffle([corr,`$${ans+1}$`,`$${ans-1}$`,`$${ans+2}$`]); arr.push({ stem:`Evaluate $${expr}$ for $x=${x}$.`, options:opts, correct: opts.indexOf(corr), explanation:`Substitute $x$ then compute.`, difficulty: i<k/3?'easy': i<2*k/3?'medium':'hard' }); } return arr; },
          'combining-like-terms': (k)=>{ const arr=[]; for(let i=0;i<k;i++){ const a=rand(1,6), b=rand(1,6), c=rand(1,6), d=rand(1,6); const ans=(a+c)+'x+'+(b+d); const corr=`$${ans}$`; const opts=shuffle([corr,`$${a}x+${b}$`,`$${c}x+${d}$`,`$${a+c}x+${b+d+1}$`]); arr.push({ stem:`Simplify $${a}x+${b}+${c}x+${d}$.`, options:opts, correct: opts.indexOf(corr), explanation:`Combine $x$ terms and constants.`, difficulty: i<k/3?'easy': i<2*k/3?'medium':'hard' }); } return arr; },
          'distributive-property': (k)=> gen['properties'](k),

          'one-step-equations': (k)=>{ const arr=[]; for(let i=0;i<k;i++){ const a=rand(2,12), x=rand(-10,10), b=a*x; const forms=[`${a}x=${b}`,`x+${a}=${a+x}`,`x-${a}=${x-a}`]; const form=choice(forms); const corr=`$${x}$`; const opts=shuffle([corr,`$${x+1}$`,`$${x-1}$`,`$${x+2}$`]); arr.push({ stem:`Solve $${form}$.`, options:opts, correct: opts.indexOf(corr), explanation:`Inverse operations.`, difficulty: i<k/3?'easy': i<2*k/3?'medium':'hard' }); } return arr; },
          'two-step-equations': (k)=>{ const arr=[]; for(let i=0;i<k;i++){ const m=rand(2,6), x=rand(-10,10), b=rand(1,10); const y=m*x+b; const corr=`$${x}$`; const forms=[`${m}x+${b}=${y}`,`${m}x-${b}=${y-2*b}`]; const form=choice(forms); const opts=shuffle([corr,`$${x+1}$`,`$${x-1}$`,`$${x+2}$`]); arr.push({ stem:`Solve $${form}$.`, options:opts, correct: opts.indexOf(corr), explanation:`Undo add/sub then divide.`, difficulty: i<k/3?'easy': i<2*k/3?'medium':'hard' }); } return arr; },
          'one-step-inequalities': (k)=>{ const arr=[]; for(let i=0;i<k;i++){ const a=rand(2,12), x=rand(-8,8); const b=a*x; const form = i%2? `x+${a}\\le ${a+x}`:`${a}x> ${b}`; const corr=`$x${i%2? '\\le '+x:'> '+x}$`; const opts=shuffle([corr,`$x<${x}$`,`$x\\ge ${x+1}$`,`$x\\le ${x-1}$`]); arr.push({ stem:`Solve ${form}$.`, options:opts, correct: opts.indexOf(corr), explanation:`Treat like equations; flip when dividing by negative.`, difficulty: i<k/3?'easy': i<2*k/3?'medium':'hard' }); } return arr; },

          // Integers: add/subtract/multiply/divide with structured difficulty
          'integer-operations': (k)=>{ const arr=[]; for(let i=0;i<k;i++){
            let stem='', corrVal=0, difficulty='easy';
            function fmt(n){ return `$${n}$`; }
            function optsFrom(val, alt){ const a = [val, val+1, val-1, alt]; return shuffle(a.map(fmt)); }
            if (i < 3){
              // Q1–Q3 easy add/sub, small magnitudes, mix signs
              const a = rand(-9,9), b = rand(-9,9); const op = (i%2===0? '+' : '-');
              corrVal = op==='+'? a+b : a-b; stem = `Compute $${a} ${op} ${b}$.`;
              const alt = op==='+'? a-b : a+b; const opts = optsFrom(corrVal, alt);
              arr.push({ stem, options:opts, correct: opts.indexOf(fmt(corrVal)), explanation:`Use integer ${op==='+'?'addition':'subtraction'} with sign rules.`, difficulty:'easy' });
            } else if (i < 6){
              // Q4–Q6 moderate subtraction/multiplication with sign rules
              difficulty='medium';
              const mode = (i%2===0? '-' : '×');
              const a = rand(-12,12), b = rand(-12,12);
              corrVal = mode==='-'? (a-b) : (a*b); stem = `Compute $${a} ${mode} ${b}$.`;
              const alt = mode==='-'? (b-a) : (Math.abs(a)*Math.abs(b));
              const opts = optsFrom(corrVal, alt);
              arr.push({ stem, options:opts, correct: opts.indexOf(fmt(corrVal)), explanation: mode==='-'?`Subtract: ${a} - (${b}) = ${corrVal}.`:`Multiply: sign is ${a*b<0?'negative':'positive'}.`, difficulty });
            } else if (i < 8){
              // Q7–Q8 harder mult/div including negatives
              difficulty='hard';
              const isDiv = (i%2===0);
              if (!isDiv){
                const a = (rand(2,15))*(Math.random()<0.5?-1:1);
                const b = (rand(2,15))*(Math.random()<0.5?-1:1);
                corrVal = a*b; stem = `Compute $${a} \u00D7 ${b}$.`;
                const alt = Math.abs(a*b); const opts = optsFrom(corrVal, alt);
                arr.push({ stem, options:opts, correct: opts.indexOf(fmt(corrVal)), explanation:`Negative×positive is negative; same signs positive.`, difficulty });
              } else {
                const d = rand(2,12), q = rand(2,12);
                const s1 = Math.random()<0.5?-1:1, s2 = Math.random()<0.5?-1:1;
                const dividend = s1*d*q, divisor = s2*d; corrVal = (dividend/divisor);
                stem = `Compute $${dividend} \div ${divisor}$.`;
                const alt = Math.abs(corrVal); const opts = optsFrom(corrVal, alt);
                arr.push({ stem, options:opts, correct: opts.indexOf(fmt(corrVal)), explanation:`Division sign rule: ${s1*s2<0?'negative':'positive'}.`, difficulty });
              }
            } else {
              // Q9–Q10 hardest mix or larger numbers with precedence
              difficulty='hard';
              const a = rand(-20,20), b = rand(-15,15), c = rand(-9,9), d = rand(2,9);
              if (Math.random()<0.5){
                stem = `Compute $( ${a}+${b} ) - ( ${c}\u00D7 ${d} )$.`;
                corrVal = (a+b) - (c*d);
                const wrongPrecedence = a + (b - c)*d; const opts = shuffle([fmt(corrVal), fmt(wrongPrecedence), fmt(corrVal+1), fmt(corrVal-1)]);
                arr.push({ stem, options:opts, correct: opts.indexOf(fmt(corrVal)), explanation:`Multiply first, then add/subtract.`, difficulty });
              } else {
                // division included with integral result
                const div = rand(2,9); const q = rand(2,9); const s = Math.random()<0.5?-1:1;
                const dividend = s*div*q; const add = rand(-10,10);
                stem = `Compute $${dividend} \div ${div} + (${a})$.`;
                corrVal = (dividend/div) + a;
                const opts = shuffle([fmt(corrVal), fmt(corrVal+1), fmt(corrVal-1), fmt((dividend+add)/div)]);
                arr.push({ stem, options:opts, correct: opts.indexOf(fmt(corrVal)), explanation:`Do division first, then addition.`, difficulty });
              }
            }
          } return arr; },

          'integer-exponents': (k)=>{ const arr=[]; for(let i=0;i<k;i++){ const a=rand(2,6), b=rand(2,6); const type=i%3; if(type===0){ const corr=`$${a**b}$`; const opts=shuffle([corr,`$${a**(b-1)}$`,`$${(a+1)**b}$`,`$${a**(b+1)}$`]); arr.push({ stem:`Evaluate $${a}^{${b}}$.`, options:opts, correct: opts.indexOf(corr), explanation:`Power definition.`, difficulty: i<k/3?'easy': i<2*k/3?'medium':'hard' }); } else if (type===1){ const m=rand(2,5), n=rand(2,5); const corr=`$a^{${m+n}}$`; const opts=shuffle([corr,`$a^{${m*n}}$`,`$a^{${m-n}}$`,`$a^{${m}}$`]); arr.push({ stem:`Simplify $a^{${m}}\cdot a^{${n}}$.`, options:opts, correct: opts.indexOf(corr), explanation:`Add exponents with same base.`, difficulty: i<k/3?'easy': i<2*k/3?'medium':'hard' }); } else { const m=rand(2,5), n=rand(2,5); const corr=`$a^{${m*n}}$`; const opts=shuffle([corr,`$a^{${m+n}}$`,`$a^{${m-n}}$`,`$a^{${m}}$`]); arr.push({ stem:`Simplify $(a^{${m}})^{${n}}$.`, options:opts, correct: opts.indexOf(corr), explanation:`Multiply exponents.`, difficulty: i<k/3?'easy': i<2*k/3?'medium':'hard' }); } } return arr; },
          'scientific-notation-intro': (k)=>{ const arr=[]; for(let i=0;i<k;i++){ const m=+(rand(10,99)/10).toFixed(1), e=rand(1,6); const N=m*10**e; const corr=`$${m}\\times 10^{${e}}$`; const opts=shuffle([corr,`$${(m/10).toFixed(1)}\\times 10^{${e+1}}$`,`$${(m*10).toFixed(1)}\\times 10^{${e-1}}$`,`$${N}$`]); arr.push({ stem:`Write $${N}$ in scientific notation.`, options:opts, correct: opts.indexOf(corr), explanation:`Move decimal to $[1,10)$ and adjust power.`, difficulty: i<k/3?'easy': i<2*k/3?'medium':'hard' }); } return arr; },

          'plotting-points': (k)=>{ const arr=[]; for(let i=0;i<k;i++){ const x=rand(-5,5), y=rand(-5,5); const corr=`$(${x},${y})$`; const opts=shuffle([corr,`$(${y},${x})$`,`$(${x},${-y})$`,`$(${y},${-x})$`]); arr.push({ stem:`Which point is shown?`, options:opts, correct: opts.indexOf(corr), explanation:`(x,y).`, difficulty: i<k/3?'easy': i<2*k/3?'medium':'hard', graph:{ expressions:[{ id:'p', type:'point', x, y }] } }); } return arr; },
          'tables-graphs': (k)=>{ const arr=[]; for(let i=0;i<k;i++){ const m=rand(1,4), b=rand(-3,3); const x=rand(0,5); const y=m*x+b; const corr=`$y=${m}x${b>=0?'+':''}${b}$`; const opts=shuffle([corr,`$y=${m+1}x${b>=0?'+':''}${b}$`,`$y=${m}x${b+1>=0?'+':''}${b+1}$`,`$y=x$`]); arr.push({ stem:`A table follows $y=${m}x${b>=0?'+':''}${b}$. Which equation matches the graph?`, options:opts, correct: opts.indexOf(corr), explanation:`Identify slope/intercept.`, difficulty: i<k/3?'easy': i<2*k/3?'medium':'hard', graph:{ expressions:[{ id:'l1', latex:`y=${m}x${b>=0?'+':''}${b}` }, { id:'p1', type:'point', x, y }] } }); } return arr; },
          'arithmetic-sequences-intro': (k)=>{ const arr=[]; for(let i=0;i<k;i++){ const a1=rand(1,9), d=rand(1,5), n=rand(4,10); const an=a1+(n-1)*d; const corr=`$${an}$`; const opts=shuffle([corr,`$${an+d}$`,`$${an-d}$`,`$${a1+n}$`]); arr.push({ stem:`For $a_1=${a1}$, $d=${d}$, find $a_${n}$.`, options:opts, correct: opts.indexOf(corr), explanation:`$a_n=a_1+(n-1)d$.`, difficulty: i<k/3?'easy': i<2*k/3?'medium':'hard' }); } return arr; },
          'mmm-range': (k)=>{ const arr=[]; for(let i=0;i<k;i++){ const data=shuffle([rand(1,20),rand(1,20),rand(1,20),rand(1,20),rand(1,20)]); const sorted=[...data].sort((a,b)=>a-b); const mean=(data.reduce((s,x)=>s+x,0)/data.length).toFixed(1); const med=sorted[2]; const mode=choice(data); const range=sorted[4]-sorted[0]; const ask=choice(['mean','median','mode','range']); let corr; if (ask==='mean') corr=`$${mean}$`; else if (ask==='median') corr=`$${med}$`; else if (ask==='mode') corr=`$${mode}$`; else corr=`$${range}$`; const opts=shuffle([corr,`$${Number(mean)+1}$`,`$${med+1}$`,`$${range+1}$`]); arr.push({ stem:`For data ${data.join(', ')}, find the ${ask}.`, options:opts, correct: opts.indexOf(corr), explanation:`Compute requested statistic.`, difficulty: i<k/3?'easy': i<2*k/3?'medium':'hard' }); } return arr; },
          'theoretical-vs-experimental': (k)=>{ const arr=[]; for(let i=0;i<k;i++){ const faces=6; const trials=rand(20,60); const exp=rand(5,15); const theo=1/6; const ask=choice(['theoretical','experimental']); const corr = ask==='theoretical'? `$${theo.toFixed(2)}$`:`$${(exp/trials).toFixed(2)}$`; const opts=shuffle([corr,`$${(1/4).toFixed(2)}$`,`$${(1/3).toFixed(2)}$`,`$${(1/2).toFixed(2)}$`]); arr.push({ stem:`A die is rolled ${trials} times and a "3" occurs ${exp} times. What is the ${ask} probability of a 3?`, options:opts, correct: opts.indexOf(corr), explanation:`Theoretical: $1/6$; Experimental: successes/trials.`, difficulty: i<k/3?'easy': i<2*k/3?'medium':'hard' }); } return arr; },
          'compound-probability': (k)=>{ const arr=[]; for(let i=0;i<k;i++){ const p1=rand(1,5)/6, p2=rand(1,5)/6; const corr = `$${(p1*p2).toFixed(2)}$`; const opts=shuffle([corr,`$${(p1+p2).toFixed(2)}$`,`$${Math.max(p1,p2).toFixed(2)}$`,`$${(p1*p2*2).toFixed(2)}$`]); arr.push({ stem:`Two independent events with $P(A)=${p1.toFixed(2)}$, $P(B)=${p2.toFixed(2)}$. Find $P(A\\cap B)$.`, options:opts, correct: opts.indexOf(corr), explanation:`Independent: multiply.`, difficulty: i<k/3?'easy': i<2*k/3?'medium':'hard' }); } return arr; },
          'unit-conversions': (k)=>{ const arr=[]; const conv=[['in','ft',12],['ft','yd',3],['cm','m',100],['g','kg',1000]]; for(let i=0;i<k;i++){ const [u1,u2,f]=choice(conv); const a=rand(2,50); const ans = u1==='in'&&u2==='ft'? +(a/12).toFixed(2) : u1==='ft'&&u2==='yd'? +(a/3).toFixed(2) : u1==='cm'&&u2==='m'? +(a/100).toFixed(2) : +(a/1000).toFixed(2); const corr=`$${ans}$`; const opts=shuffle([corr,`$${(ans+1)}$`,`$${(ans-1)}$`,`$${(ans*2)}$`]); arr.push({ stem:`Convert $${a}\\ ${u1}$ to ${u2}.`, options:opts, correct: opts.indexOf(corr), explanation:`Use conversion factor ${f}.`, difficulty: i<k/3?'easy': i<2*k/3?'medium':'hard' }); } return arr; },
          'rates-per': (k)=>{ const arr=[]; for(let i=0;i<k;i++){ const miles=rand(30,300), hours=rand(1,6); const mph=+(miles/hours).toFixed(1); const corr=`$${mph}$`; const opts=shuffle([corr,`$${mph+1}$`,`$${mph-1}$`,`$${mph+5}$`]); arr.push({ stem:`A car travels ${miles} miles in ${hours} hours. What is the speed (mph)?`, options:opts, correct: opts.indexOf(corr), explanation:`Rate = distance/time.`, difficulty: i<k/3?'easy': i<2*k/3?'medium':'hard' }); } return arr; }
        };

        // If a dedicated generator exists for the lesson slug, use it
        if (gen[slug]) return gen[slug](count);
        for (let i=0;i<count;i++){
          if (slug.includes('lcm')){
            const mode = (i < Math.floor(count/3)) ? 'easy' : (i < Math.floor(2*count/3) ? 'medium' : 'hard');
            function choicesOf(correct){
              const c = correct;
              const near = Math.max(1, c - rand(1, Math.max(2, Math.floor(c*0.25))));
              const up = c + rand(1, Math.max(2, Math.floor(c*0.25)));
              const half = Math.max(1, Math.floor(c/2));
              const doubled = c*2;
              return _.shuffle([c, up, near, doubled, half]).slice(0,4).map(v=> `$${v}$`);
            }
            if (mode === 'easy'){
              const base = rand(2,8); const a = base * rand(1,3); const b = base * rand(1,3);
              const ans = lcm(a,b); const opts = choicesOf(ans);
              out.push({ stem:`Find $\\operatorname{LCM}(${a},${b})$.`, options: opts, correct: opts.indexOf(`$${ans}$`), explanation:`Use prime powers or $\\mathrm{lcm}(a,b)=\\dfrac{ab}{\\gcd(a,b)}=${ans}$.`, difficulty:'easy' });
            } else if (mode === 'medium'){
              const a = rand(9,20), b = rand(12,30); const ans = lcm(a,b); const opts = choicesOf(ans);
              out.push({ stem:`Compute $\\operatorname{LCM}(${a},${b})$.`, options: opts, correct: opts.indexOf(`$${ans}$`), explanation:`Factor and take highest prime powers.`, difficulty:'medium' });
            } else {
              if (i % 2 === 0){
                const a = rand(4,15), b = rand(6,20), c = rand(5,18); const ans = lcm(lcm(a,b), c); const opts = choicesOf(ans);
                out.push({ stem:`Find $\\operatorname{LCM}(${a},${b},${c})$.`, options: opts, correct: opts.indexOf(`$${ans}$`), explanation:`$\\mathrm{lcm}(a,b,c)=\\mathrm{lcm}(\\mathrm{lcm}(a,b),c)=${ans}$.`, difficulty:'hard' });
              } else {
                const a = [6,8,9,10,12,14,15,18,20][rand(0,8)]; const b = [7,9,10,12,16,18,21,24,30][rand(0,8)];
                const ans = lcm(a,b); const opts = choicesOf(ans);
                out.push({ stem:`Bus A arrives every ${a} minutes and Bus B every ${b} minutes. In how many minutes will both arrive together?`, options: opts, correct: opts.indexOf(`$${ans}$`), explanation:`Synchronize cycles using LCM = ${ans} minutes.`, difficulty:'hard' });
              }
            }
            continue;
          }
          if (slug.includes('gcf')){
            const a = rand(10,60), b = rand(10,60);
            const ans = gcd(a,b);
            const opts = _.shuffle([ans, ans+rand(1,4), Math.max(ans-rand(1,4),1), rand(2,9)]).map(v=> `$${v}$`);
            out.push({ stem:`Find $\\operatorname{GCF}(${a},${b})$.`, options: opts, correct: opts.indexOf(`$${ans}$`), explanation:`Common factors; $\\gcd(${a},${b})=${ans}$.`, difficulty: i< count/3?'easy': i< 2*count/3?'medium':'hard' });
            continue;
          }
          if (slug.includes('divisibility-prime-composite')){
            const n = rand(10,150);
            const qtype = rand(0,1);
            if (qtype===0){
              const d = [2,3,4,5,6,9,10][rand(0,6)];
              const isDiv = n%d===0;
              const opts = isDiv ? ['Yes','No','Only if even','Only if odd'] : ['No','Yes','Only if even','Only if odd'];
              out.push({ stem:`Is $${n}$ divisible by $${d}$?`, options: opts, correct: isDiv?0:1, explanation:`Check divisibility rule for ${d}.`, difficulty: i< count/3?'easy': i< 2*count/3?'medium':'hard' });
            } else {
              // prime vs composite (simple heuristic)
              function isPrime(k){ if (k<2) return false; for (let p=2;p*p<=k;p++){ if (k%p===0) return false; } return true; }
              const prime = isPrime(n);
              const opts = ['Prime','Composite','Even','Odd'];
              out.push({ stem:`Is $${n}$ prime or composite?`, options: opts, correct: prime?0:1, explanation:`${n} is ${prime?'prime (no factors besides 1 and itself)':'composite (has other factors)'} .`, difficulty: i< count/3?'easy': i< 2*count/3?'medium':'hard' });
            }
            continue;
          }
          if (slug.includes('place-value')){
            const n = rand(1000,999999);
            const place = ['nearest ten','nearest hundred','nearest thousand'][rand(0,2)];
            const rounded = place==='nearest ten'? Math.round(n/10)*10 : place==='nearest hundred'? Math.round(n/100)*100 : Math.round(n/1000)*1000;
            out.push({ stem:`Round $${n}$ to the ${place}.`, options:[`$${rounded}$`,`$${rounded+ (place==='nearest ten'?10:place==='nearest hundred'?100:1000)}$`,`$${rounded-(place==='nearest ten'?10:place==='nearest hundred'?100:1000)}$`,`$${rounded + (place==='nearest ten'?5:place==='nearest hundred'?50:500)}$`], correct:0, explanation:`Rounding to the ${place} gives $${rounded}$.`, difficulty: i< count/3?'easy': i< 2*count/3?'medium':'hard' });
          } else if (slug.includes('integer-operations')){
            const a = rand(-20,20), b = rand(-20,20); const op = ['+','-','×','÷'][rand(0,3)];
            let ans; if (op==='+') ans=a+b; else if (op==='-') ans=a-b; else if (op==='×') ans=a*b; else { const bb = b||1; ans = Math.trunc(a/bb); }
            const opts = [ans, ans+1, ans-1, ans+2].map(v=> `$${v}$`);
            out.push({ stem:`Compute $${a} ${op} ${b}$.`, options: _.shuffle(opts), correct:0, explanation:`$= ${ans}$`, difficulty: i< count/3?'easy': i< 2*count/3?'medium':'hard' });
          } else if (slug.includes('absolute-value')){
            const a = rand(-15,15); const ans = Math.abs(a);
            out.push({ stem:`Evaluate $|${a}|$.`, options:[`$${ans}$`,`$${-ans}$`,`$${ans+1}$`,`$${ans-1}$`], correct:0, explanation:`Distance from 0 is $${ans}$.`, difficulty: i< count/3?'easy': i< 2*count/3?'medium':'hard' });
          } else if (slug.includes('equivalent-simplifying')){
            const a = rand(2,12), b = a*rand(2,10); const c = rand(2,12), d = c*rand(2,10);
            const g = (x,y)=> y? g(y, x%y): x; const num = b/g(b,a), den = a/g(b,a);
            out.push({ stem:`Simplify $\frac{${b}}{${a}}$.`, options:[`$\\dfrac{${num}}{${den}}$`,`$\\dfrac{${num+1}}{${den}}$`,`$\\dfrac{${num}}{${den+1}}$`,`$\\dfrac{${num-1}}{${den-1}}$`], correct:0, explanation:`Divide numerator and denominator by GCF.`, difficulty: i< count/3?'easy': i< 2*count/3?'medium':'hard' });
          } else if (slug.includes('decimal-operations')){
            const a = (rand(10,999)/10).toFixed(1), b = (rand(10,999)/10).toFixed(1);
            const op = ['+','-','×'][rand(0,2)];
            let ans = op==='+'? (Number(a)+Number(b)) : op==='-'? (Number(a)-Number(b)) : (Number(a)*Number(b));
            ans = Number(ans.toFixed(2));
            const opts = [ans, Number((ans+0.1).toFixed(2)), Number((ans-0.1).toFixed(2)), Number((ans+1).toFixed(2))].map(v=> `$${v}$`);
            out.push({ stem:`Compute $${a} ${op} ${b}$.`, options: _.shuffle(opts), correct:0, explanation:`$= ${ans}$.`, difficulty: i< count/3?'easy': i< 2*count/3?'medium':'hard' });
          } else if (slug.includes('convert-percent')){
            const p = rand(5,95);
            out.push({ stem:`Convert $${p}\%$ to a decimal.`, options:[`$${(p/100).toFixed(2)}$`,`$${p}$`,`$${(p*100)}$`,`$${(100/p).toFixed(2)}$`], correct:0, explanation:`Divide by $100$: $${(p/100).toFixed(2)}$.`, difficulty: i< count/3?'easy': i< 2*count/3?'medium':'hard' });
          } else if (slug.includes('one-step-equations')){
            const a = rand(2,12), x = rand(-10,10), b = a*x; const form = rand(0,1)? `${a}x=${b}` : `x+${a}=${a+x}`;
            const ans = x;
            out.push({ stem:`Solve $${form}$.`, options:[`$${ans}$`,`$${ans+1}$`,`$${ans-1}$`,`$${ans+2}$`], correct:0, explanation:`Inverse operations give $x=${ans}$.`, difficulty: i< count/3?'easy': i< 2*count/3?'medium':'hard' });
          } else if (slug.includes('pemdas')){
            const a = rand(1,9), b = rand(1,9), c = rand(1,9);
            const stem = `$${a}+(${b}\times ${c})$`;
            const ans = a + b*c;
            out.push({ stem:`Evaluate ${stem}.`, options:[`$${ans}$`,`$${a*b+c}$`,`$${a+b+c}$`,`$${(a+b)*c}$`], correct:0, explanation:`Multiply first: ${b}×${c}=${b*c}, then add ${a}.`, difficulty: i< count/3?'easy': i< 2*count/3?'medium':'hard' });
          } else if (slug.includes('plotting-points') || slug.includes('coordinate')){
            const x = rand(-5,5), y = rand(-5,5);
            const graph = { expressions:[ { id:'p1', latex:`(x-${x})^2+(y-${y})^2=0` } ] };
            out.push({ stem:`Which point is shown?`, options:[`$(${x},${y})$`,`$(${y},${x})$`,`$(${x},${-y})$`,`$(${y},${-x})$`], correct:0, explanation:`Coordinates read (x,y).`, difficulty: i< count/3?'easy': i< 2*count/3?'medium':'hard', graph });
          } else {
            // generic linear solve
            const n = rand(1,10);
            const stem = `Solve $x+${n}=${n*2}$.`;
            const ans = n; const opts = [ans, ans+1, ans-1, ans+2].map(v=> `$${v}$`);
            out.push({ stem, options: _.shuffle(opts), correct:0, explanation:`$x=${ans}$`, difficulty: i< count/3?'easy': i< 2*count/3?'medium':'hard' });
          }
        }
        return out;
      }

      function averageProgress(arr){
        if (!arr.length) return 0;
        return arr.reduce((s,l)=> s + (l.progress||0), 0) / arr.length;
      }

      // ===== 3D Carousel with keyboard/click/double-click =====
      const shelf = document.getElementById('psShelf');
      const openBtn = document.getElementById('psOpenBtn');
      const grid = document.getElementById('psBooksGrid');
      const BOOKS = [
        { id:'algebra-1', label:'Pre‑Algebra' },
        { id:'geometry', label:'Geometry' },
        { id:'algebra', label:'Algebra' },
        { id:'algebra-2', label:'Algebra II' },
        { id:'precalculus', label:'Pre‑Calculus' },
        { id:'calculus', label:'Calculus' },
      ];
      function renderGrid(){
        grid.innerHTML = '';
        BOOKS.forEach(b => {
          const tile = document.createElement('div'); tile.className='ps-book-tile';
          const cover = document.createElement('div'); cover.className='ps-book-cover'; cover.textContent=b.label; tile.appendChild(cover);
          tile.addEventListener('click', ()=> enterSubject(b.id));
          grid.appendChild(tile);
        });
      }
      renderGrid();

      // Ensure shelf shows on initial load (no deep link)
      (function(){
        try {
          const hash = (location.hash||'').replace('#','');
          const parts = hash ? hash.replace(/^\/?/, '').split('/') : [];
          if (!(parts.length >= 4)){
            const app = document.getElementById('psApp');
            const shelfEl = document.getElementById('psShelf');
            if (app) app.hidden = true;
            if (shelfEl) shelfEl.style.display = '';
          }
        } catch{}
      })();

      // Redundant safety: on DOM ready, if no deep link, ensure shelf is visible and grid populated
      document.addEventListener('DOMContentLoaded', function(){
        try {
          const hash = (location.hash||'').replace('#','');
          if (!hash || hash.replace(/^\/?/, '').split('/').length < 4){
            const app = document.getElementById('psApp');
            const shelfEl = document.getElementById('psShelf');
            const gridEl = document.getElementById('psBooksGrid');
            if (app) app.hidden = true;
            if (shelfEl) shelfEl.style.display = '';
            if (gridEl && gridEl.childElementCount === 0) renderGrid();
          }
        } catch{}
      });

      let currentCourseId = null;
      function enterSubject(subjectId){
        // show app and render sidebar; default lesson of that subject
        document.getElementById('psApp').hidden = false;
        currentCourseId = subjectId; renderSidebar();
        const c = COURSES.find(c=>c.id===subjectId) || COURSES[0];
        if (c) loadLesson(c.id, c.subtopics[0].id, c.subtopics[0].lessons[0].slug);
        // hide shelf grid after selection
        shelf.style.display='none';
        history.replaceState(null, '', `problem-sets.html#/${subjectId}/${c.subtopics[0].id}/${c.subtopics[0].lessons[0].slug}`);
      }

      // deep-link (hash)
      try {
        const hash = (location.hash||'').replace('#','');
        if (hash){
          const parts = hash.replace(/^\/?/, '').split('/');
          if (parts.length >= 4){
            document.getElementById('psApp').hidden = false; currentCourseId = parts[1]; renderSidebar();
            loadLesson(parts[1], parts[2], parts[3]);
            document.getElementById('psShelf').style.display='none';
          }
        }
      } catch{}
    </script>
    <script>window.TBP_AUTH_BASE='https://cramprep.onrender.com';</script>
    <script>
      window.TBP_GEMINI_API_KEY = 'AIzaSyDA_Rkb7-nIU25gGhuRs6yLmMFHmccpR8c';
      try { localStorage.setItem('tbp_gemini_key', window.TBP_GEMINI_API_KEY); } catch{}
    </script>
    <script src="index.js"></script>
    <script src="login.js?v=1.0"></script>
    <!-- Removed floating Study AI; Study AI can still be opened from Tools menu -->
    <!-- Hidden Study AI trigger and required assets -->
    <button data-open="study-ai" id="study-ai-trigger" style="display:none"></button>
    <link rel="stylesheet" href="/assets/ai-chatbot/style.css">
    <script src="/assets/studyaigoby_script.js"></script>
  </body>
  </html>


